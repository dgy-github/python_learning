# 第六课：高级数据结构与算法

**预计时长：200分钟**
 **难度等级：⭐⭐⭐⭐**

------

## 📚 课程目录

1. [数据结构基础回顾](#51-数据结构基础回顾-25分钟)
2. [栈（Stack）](#52-栈stack-25分钟)
3. [队列（Queue）](#53-队列queue-25分钟)
4. [链表（Linked List）](#54-链表linked-list-30分钟)
5. [树（Tree）](#55-树tree-35分钟)
6. [哈希表（Hash Table）](#56-哈希表hash-table-25分钟)
7. [算法复杂度分析](#57-算法复杂度分析-20分钟)
8. [实战项目：任务调度系统](#58-实战项目任务调度系统-40分钟)

------

## 5.1 数据结构基础回顾 (25分钟)

### 5.1.1 什么是数据结构？

**数据结构**是计算机存储、组织数据的方式。选择合适的数据结构可以提高算法效率。

```
scss复制数据结构分类：
┌─────────────────────────────────────┐
│ 线性结构                            │
│  ├─ 数组 (Array)                    │
│  ├─ 链表 (Linked List)              │
│  ├─ 栈 (Stack)                      │
│  └─ 队列 (Queue)                    │
├─────────────────────────────────────┤
│ 非线性结构                          │
│  ├─ 树 (Tree)                       │
│  ├─ 图 (Graph)                      │
│  └─ 堆 (Heap)                       │
├─────────────────────────────────────┤
│ 哈希结构                            │
│  └─ 哈希表 (Hash Table)             │
└─────────────────────────────────────┘
```

------

### 5.1.2 内置数据结构对比

#### Python内置数据结构

```
python复制# 1. 列表 (List) - 动态数组
my_list = [1, 2, 3, 4, 5]
my_list.append(6)        # O(1) - 末尾添加
my_list.insert(0, 0)     # O(n) - 开头插入
my_list.pop()            # O(1) - 末尾删除
my_list.pop(0)           # O(n) - 开头删除
print(my_list[2])        # O(1) - 索引访问

# 2. 元组 (Tuple) - 不可变序列
my_tuple = (1, 2, 3, 4, 5)
# my_tuple[0] = 10  # TypeError: 不可修改
print(my_tuple[2])       # O(1) - 索引访问

# 3. 集合 (Set) - 无序不重复
my_set = {1, 2, 3, 4, 5}
my_set.add(6)            # O(1) - 添加
my_set.remove(3)         # O(1) - 删除
print(2 in my_set)       # O(1) - 查找

# 4. 字典 (Dictionary) - 键值对
my_dict = {'a': 1, 'b': 2, 'c': 3}
my_dict['d'] = 4         # O(1) - 添加
del my_dict['a']         # O(1) - 删除
print(my_dict['b'])      # O(1) - 访问

# 5. 双端队列 (Deque)
from collections import deque
my_deque = deque([1, 2, 3, 4, 5])
my_deque.append(6)       # O(1) - 右端添加
my_deque.appendleft(0)   # O(1) - 左端添加
my_deque.pop()           # O(1) - 右端删除
my_deque.popleft()       # O(1) - 左端删除
```

#### Java内置数据结构

```
java复制import java.util.*;

public class DataStructuresDemo {
    public static void main(String[] args) {
        // 1. ArrayList - 动态数组
        ArrayList<Integer> arrayList = new ArrayList<>();
        arrayList.add(1);              // O(1) - 末尾添加
        arrayList.add(0, 0);           // O(n) - 开头插入
        arrayList.remove(arrayList.size() - 1);  // O(1) - 末尾删除
        arrayList.remove(0);           // O(n) - 开头删除
        System.out.println(arrayList.get(0));    // O(1) - 索引访问
        
        // 2. LinkedList - 链表
        LinkedList<Integer> linkedList = new LinkedList<>();
        linkedList.add(1);             // O(1) - 末尾添加
        linkedList.addFirst(0);        // O(1) - 开头添加
        linkedList.removeLast();       // O(1) - 末尾删除
        linkedList.removeFirst();      // O(1) - 开头删除
        
        // 3. HashSet - 哈希集合
        HashSet<Integer> hashSet = new HashSet<>();
        hashSet.add(1);                // O(1) - 添加
        hashSet.remove(1);             // O(1) - 删除
        System.out.println(hashSet.contains(1));  // O(1) - 查找
        
        // 4. HashMap - 哈希映射
        HashMap<String, Integer> hashMap = new HashMap<>();
        hashMap.put("a", 1);           // O(1) - 添加
        hashMap.remove("a");           // O(1) - 删除
        System.out.println(hashMap.get("a"));     // O(1) - 访问
        
        // 5. Stack - 栈
        Stack<Integer> stack = new Stack<>();
        stack.push(1);                 // O(1) - 压栈
        stack.pop();                   // O(1) - 出栈
        
        // 6. Queue - 队列
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(1);                // O(1) - 入队
        queue.poll();                  // O(1) - 出队
    }
}
```

------

### 5.1.3 时间复杂度对比表

| 数据结构       | 访问     | 搜索     | 插入     | 删除     | 空间复杂度 |
| -------------- | -------- | -------- | -------- | -------- | ---------- |
| **数组**       | O(1)     | O(n)     | O(n)     | O(n)     | O(n)       |
| **链表**       | O(n)     | O(n)     | O(1)     | O(1)     | O(n)       |
| **栈**         | O(n)     | O(n)     | O(1)     | O(1)     | O(n)       |
| **队列**       | O(n)     | O(n)     | O(1)     | O(1)     | O(n)       |
| **哈希表**     | N/A      | O(1)     | O(1)     | O(1)     | O(n)       |
| **二叉搜索树** | O(log n) | O(log n) | O(log n) | O(log n) | O(n)       |
| **堆**         | O(1)     | O(n)     | O(log n) | O(log n) | O(n)       |

------

## 5.2 栈（Stack） (25分钟)

### 5.2.1 栈的概念

**栈（Stack）**是一种后进先出（LIFO - Last In First Out）的数据结构。

```
scss复制栈的操作：
    ┌───┐
    │ 3 │ ← top (栈顶)
    ├───┤
    │ 2 │
    ├───┤
    │ 1 │
    └───┘

push(4):  添加元素到栈顶
pop():    移除并返回栈顶元素
peek():   查看栈顶元素（不移除）
isEmpty(): 检查栈是否为空
```

------

### 5.2.2 Python实现栈

```
python复制class Stack:
    """栈的实现（使用列表）"""
    
    def __init__(self):
        self.items = []
    
    def is_empty(self):
        """检查栈是否为空"""
        return len(self.items) == 0
    
    def push(self, item):
        """压栈"""
        self.items.append(item)
    
    def pop(self):
        """出栈"""
        if self.is_empty():
            raise IndexError("Pop from empty stack")
        return self.items.pop()
    
    def peek(self):
        """查看栈顶元素"""
        if self.is_empty():
            raise IndexError("Peek from empty stack")
        return self.items[-1]
    
    def size(self):
        """返回栈的大小"""
        return len(self.items)
    
    def __str__(self):
        return f"Stack({self.items})"


# 使用栈
stack = Stack()
print(f"栈是否为空: {stack.is_empty()}")  # True

# 压栈
stack.push(1)
stack.push(2)
stack.push(3)
print(stack)  # Stack([1, 2, 3])

# 查看栈顶
print(f"栈顶元素: {stack.peek()}")  # 3

# 出栈
print(f"出栈: {stack.pop()}")  # 3
print(f"出栈: {stack.pop()}")  # 2
print(stack)  # Stack([1])

print(f"栈的大小: {stack.size()}")  # 1
```

------

### 5.2.3 Java实现栈

```
java复制public class Stack<T> {
    private ArrayList<T> items;
    
    public Stack() {
        items = new ArrayList<>();
    }
    
    // 检查栈是否为空
    public boolean isEmpty() {
        return items.isEmpty();
    }
    
    // 压栈
    public void push(T item) {
        items.add(item);
    }
    
    // 出栈
    public T pop() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return items.remove(items.size() - 1);
    }
    
    // 查看栈顶元素
    public T peek() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return items.get(items.size() - 1);
    }
    
    // 返回栈的大小
    public int size() {
        return items.size();
    }
    
    @Override
    public String toString() {
        return "Stack" + items.toString();
    }
    
    // 测试
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        System.out.println("栈是否为空: " + stack.isEmpty());  // true
        
        // 压栈
        stack.push(1);
        stack.push(2);
        stack.push(3);
        System.out.println(stack);  // Stack[1, 2, 3]
        
        // 查看栈顶
        System.out.println("栈顶元素: " + stack.peek());  // 3
        
        // 出栈
        System.out.println("出栈: " + stack.pop());  // 3
        System.out.println("出栈: " + stack.pop());  // 2
        System.out.println(stack);  // Stack[1]
        
        System.out.println("栈的大小: " + stack.size());  // 1
    }
}
```

------

### 5.2.4 栈的应用

#### 应用1：括号匹配

```
python复制def is_balanced_parentheses(expression):
    """检查括号是否匹配"""
    stack = Stack()
    opening = "({["
    closing = ")}]"
    pairs = {"(": ")", "{": "}", "[": "]"}
    
    for char in expression:
        if char in opening:
            stack.push(char)
        elif char in closing:
            if stack.is_empty():
                return False
            top = stack.pop()
            if pairs[top] != char:
                return False
    
    return stack.is_empty()


# 测试
print(is_balanced_parentheses("()"))           # True
print(is_balanced_parentheses("()[]{}"))       # True
print(is_balanced_parentheses("(]"))           # False
print(is_balanced_parentheses("([)]"))         # False
print(is_balanced_parentheses("{[()]}"))       # True
print(is_balanced_parentheses("((()"))         # False

```

#### 应用2：表达式求值（后缀表达式）

```
python复制def evaluate_postfix(expression):
    """
    计算后缀表达式（逆波兰表达式）
    例如: "2 3 + 4 *" = (2 + 3) * 4 = 20
    """
    stack = Stack()
    operators = {'+', '-', '*', '/'}
    
    tokens = expression.split()
    
    for token in tokens:
        if token not in operators:
            # 数字，压入栈
            stack.push(float(token))
        else:
            # 运算符，弹出两个操作数
            if stack.size() < 2:
                raise ValueError("Invalid expression")
            
            operand2 = stack.pop()
            operand1 = stack.pop()
            
            # 执行运算
            if token == '+':
                result = operand1 + operand2
            elif token == '-':
                result = operand1 - operand2
            elif token == '*':
                result = operand1 * operand2
            elif token == '/':
                if operand2 == 0:
                    raise ValueError("Division by zero")
                result = operand1 / operand2
            
            stack.push(result)
    
    if stack.size() != 1:
        raise ValueError("Invalid expression")
    
    return stack.pop()


# 测试
print(evaluate_postfix("2 3 +"))           # 5.0
print(evaluate_postfix("2 3 + 4 *"))       # 20.0
print(evaluate_postfix("5 1 2 + 4 * + 3 -")) # 14.0
```

#### 应用3：函数调用栈

```
python复制def factorial(n):
    """
    递归计算阶乘
    调用栈演示：
    factorial(3)
      → factorial(2)
        → factorial(1)
          → factorial(0)
          ← return 1
        ← return 1 * 1 = 1
      ← return 2 * 1 = 2
    ← return 3 * 2 = 6
    """
    print(f"调用 factorial({n})")
    if n <= 1:
        print(f"返回 1")
        return 1
    result = n * factorial(n - 1)
    print(f"返回 {n} * factorial({n-1}) = {result}")
    return result


print("\n阶乘计算过程：")
print(f"结果: {factorial(4)}")
```

#### 应用4：浏览器历史记录

```
python复制class BrowserHistory:
    """浏览器历史记录（使用两个栈）"""
    
    def __init__(self, homepage):
        self.back_stack = Stack()
        self.forward_stack = Stack()
        self.current = homepage
    
    def visit(self, url):
        """访问新页面"""
        self.back_stack.push(self.current)
        self.current = url
        # 访问新页面后，前进历史清空
        self.forward_stack = Stack()
        print(f"访问: {url}")
    
    def back(self):
        """后退"""
        if self.back_stack.is_empty():
            print("无法后退")
            return self.current
        
        self.forward_stack.push(self.current)
        self.current = self.back_stack.pop()
        print(f"后退到: {self.current}")
        return self.current
    
    def forward(self):
        """前进"""
        if self.forward_stack.is_empty():
            print("无法前进")
            return self.current
        
        self.back_stack.push(self.current)
        self.current = self.forward_stack.pop()
        print(f"前进到: {self.current}")
        return self.current
    
    def current_page(self):
        """当前页面"""
        return self.current


# 使用浏览器历史
browser = BrowserHistory("google.com")
browser.visit("youtube.com")
browser.visit("github.com")
browser.visit("stackoverflow.com")
print(f"当前页面: {browser.current_page()}")

browser.back()    # 回到 github.com
browser.back()    # 回到 youtube.com
browser.forward() # 前进到 github.com
browser.visit("reddit.com")  # 访问新页面，前进历史清空
browser.forward() # 无法前进
```

------

## 5.3 队列（Queue） (25分钟)

### 5.3.1 队列的概念

**队列（Queue）**是一种先进先出（FIFO - First In First Out）的数据结构。

```
scss复制队列的操作：
    front                    rear
      ↓                        ↓
    ┌───┬───┬───┬───┬───┐
    │ 1 │ 2 │ 3 │ 4 │ 5 │
    └───┴───┴───┴───┴───┘

enqueue(6): 在队尾添加元素
dequeue():  从队首移除并返回元素
peek():     查看队首元素（不移除）
isEmpty():  检查队列是否为空
```

------

### 5.3.2 Python实现队列

```
python复制from collections import deque

class Queue:
    """队列的实现（使用deque）"""
    
    def __init__(self):
        self.items = deque()
    
    def is_empty(self):
        """检查队列是否为空"""
        return len(self.items) == 0
    
    def enqueue(self, item):
        """入队（在队尾添加）"""
        self.items.append(item)
    
    def dequeue(self):
        """出队（从队首移除）"""
        if self.is_empty():
            raise IndexError("Dequeue from empty queue")
        return self.items.popleft()
    
    def peek(self):
        """查看队首元素"""
        if self.is_empty():
            raise IndexError("Peek from empty queue")
        return self.items[0]
    
    def size(self):
        """返回队列大小"""
        return len(self.items)
    
    def __str__(self):
        return f"Queue({list(self.items)})"


# 使用队列
queue = Queue()
print(f"队列是否为空: {queue.is_empty()}")  # True

# 入队
queue.enqueue(1)
queue.enqueue(2)
queue.enqueue(3)
print(queue)  # Queue([1, 2, 3])

# 查看队首
print(f"队首元素: {queue.peek()}")  # 1

# 出队
print(f"出队: {queue.dequeue()}")  # 1
print(f"出队: {queue.dequeue()}")  # 2
print(queue)  # Queue([3])

print(f"队列大小: {queue.size()}")  # 1
```

------

### 5.3.3 循环队列

```
python复制class CircularQueue:
    """循环队列（固定大小）"""
    
    def __init__(self, capacity):
        self.capacity = capacity
        self.items = [None] * capacity
        self.front = 0
        self.rear = 0
        self.count = 0
    
    def is_empty(self):
        return self.count == 0
    
    def is_full(self):
        return self.count == self.capacity
    
    def enqueue(self, item):
        """入队"""
        if self.is_full():
            raise OverflowError("Queue is full")
        
        self.items[self.rear] = item
        self.rear = (self.rear + 1) % self.capacity
        self.count += 1
    
    def dequeue(self):
        """出队"""
        if self.is_empty():
            raise IndexError("Dequeue from empty queue")
        
        item = self.items[self.front]
        self.items[self.front] = None
        self.front = (self.front + 1) % self.capacity
        self.count -= 1
        return item
    
    def peek(self):
        """查看队首元素"""
        if self.is_empty():
            raise IndexError("Peek from empty queue")
        return self.items[self.front]
    
    def size(self):
        return self.count
    
    def __str__(self):
        if self.is_empty():
            return "CircularQueue([])"
        
        result = []
        index = self.front
        for _ in range(self.count):
            result.append(self.items[index])
            index = (index + 1) % self.capacity
        return f"CircularQueue({result})"


# 使用循环队列
cq = CircularQueue(5)
print(f"队列是否为空: {cq.is_empty()}")  # True

# 入队
for i in range(1, 6):
    cq.enqueue(i)
print(cq)  # CircularQueue([1, 2, 3, 4, 5])
print(f"队列是否满: {cq.is_full()}")  # True

# 出队
print(f"出队: {cq.dequeue()}")  # 1
print(f"出队: {cq.dequeue()}")  # 2

# 再入队
cq.enqueue(6)
cq.enqueue(7)
print(cq)  # CircularQueue([3, 4, 5, 6, 7])
```

------

### 5.3.4 Java实现队列

```
java复制import java.util.LinkedList;

public class Queue<T> {
    private LinkedList<T> items;
    
    public Queue() {
        items = new LinkedList<>();
    }
    
    // 检查队列是否为空
    public boolean isEmpty() {
        return items.isEmpty();
    }
    
    // 入队
    public void enqueue(T item) {
        items.addLast(item);
    }
    
    // 出队
    public T dequeue() {
        if (isEmpty()) {
            throw new IllegalStateException("Dequeue from empty queue");
        }
        return items.removeFirst();
    }
    
    // 查看队首元素
    public T peek() {
        if (isEmpty()) {
            throw new IllegalStateException("Peek from empty queue");
        }
        return items.getFirst();
    }
    
    // 返回队列大小
    public int size() {
        return items.size();
    }
    
    @Override
    public String toString() {
        return "Queue" + items.toString();
    }
    
    // 测试
    public static void main(String[] args) {
        Queue<Integer> queue = new Queue<>();
        System.out.println("队列是否为空: " + queue.isEmpty());  // true
        
        // 入队
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        System.out.println(queue);  // Queue[1, 2, 3]
        
        // 查看队首
        System.out.println("队首元素: " + queue.peek());  // 1
        
        // 出队
        System.out.println("出队: " + queue.dequeue());  // 1
        System.out.println("出队: " + queue.dequeue());  // 2
        System.out.println(queue);  // Queue[3]
        
        System.out.println("队列大小: " + queue.size());  // 1
    }
}
```

------

### 5.3.5 队列的应用

#### 应用1：广度优先搜索（BFS）

```
python复制def bfs_tree(root):
    """
    树的广度优先遍历
    """
    if not root:
        return []
    
    result = []
    queue = Queue()
    queue.enqueue(root)
    
    while not queue.is_empty():
        node = queue.dequeue()
        result.append(node.value)
        
        # 将子节点加入队列
        if node.left:
            queue.enqueue(node.left)
        if node.right:
            queue.enqueue(node.right)
    
    return result
```

#### 应用2：打印队列（Print Queue）

```
python复制class PrintJob:
    """打印任务"""
    def __init__(self, name, pages):
        self.name = name
        self.pages = pages
    
    def __str__(self):
        return f"PrintJob({self.name}, {self.pages} pages)"


class PrintQueue:
    """打印队列"""
    
    def __init__(self):
        self.queue = Queue()
    
    def add_job(self, job):
        """添加打印任务"""
        self.queue.enqueue(job)
        print(f"添加任务: {job}")
    
    def process_job(self):
        """处理一个打印任务"""
        if self.queue.is_empty():
            print("没有待处理的任务")
            return None
        
        job = self.queue.dequeue()
        print(f"正在打印: {job}")
        return job
    
    def pending_jobs(self):
        """返回待处理任务数"""
        return self.queue.size()


# 使用打印队列
printer = PrintQueue()
printer.add_job(PrintJob("Document1.pdf", 10))
printer.add_job(PrintJob("Report.docx", 5))
printer.add_job(PrintJob("Photo.jpg", 1))

print(f"\n待处理任务数: {printer.pending_jobs()}\n")

printer.process_job()
printer.process_job()
print(f"\n待处理任务数: {printer.pending_jobs()}\n")
printer.process_job()
printer.process_job()
```

#### 应用3：任务调度

```
python复制import time
from datetime import datetime

class Task:
    """任务类"""
    def __init__(self, name, priority=0):
        self.name = name
        self.priority = priority
        self.created_at = datetime.now()
    
    def execute(self):
        print(f"执行任务: {self.name}")
        time.sleep(0.5)  # 模拟任务执行
    
    def __str__(self):
        return f"Task({self.name}, priority={self.priority})"


class TaskScheduler:
    """任务调度器"""
    
    def __init__(self):
        self.queue = Queue()
    
    def add_task(self, task):
        """添加任务"""
        self.queue.enqueue(task)
        print(f"添加任务: {task}")
    
    def run(self):
        """运行所有任务"""
        print("\n开始执行任务...")
        while not self.queue.is_empty():
            task = self.queue.dequeue()
            task.execute()
        print("所有任务执行完毕")


# 使用任务调度器
scheduler = TaskScheduler()
scheduler.add_task(Task("发送邮件"))
scheduler.add_task(Task("生成报告"))
scheduler.add_task(Task("备份数据"))
scheduler.run()
```

------

## 5.4 链表（Linked List） (30分钟)

### 5.4.1 链表的概念

**链表（Linked List）**是一种线性数据结构，元素不连续存储，通过指针连接。

```
bash复制单向链表：
    head
     ↓
   ┌───┬──┐   ┌───┬──┐   ┌───┬──┐   ┌───┬──┐
   │ 1 │ ●─→  │ 2 │ ●─→  │ 3 │ ●─→  │ 4 │ ✗│
   └───┴──┘   └───┴──┘   └───┴──┘   └───┴──┘

双向链表：
    head
     ↓
   ┌──┬───┬──┐   ┌──┬───┬──┐   ┌──┬───┬──┐
   │✗ │ 1 │ ●─→←─● │ 2 │ ●─→←─● │ 3 │ ✗│
   └──┴───┴──┘   └──┴───┴──┘   └──┴───┴──┘
```

**优点：**

- 动态大小
- 插入/删除高效（O(1)）

**缺点：**

- 访问元素慢（O(n)）
- 额外的内存开销（存储指针）

------

### 5.4.2 Python实现单向链表

```
python复制class Node:
    """链表节点"""
    def __init__(self, data):
        self.data = data
        self.next = None
    
    def __str__(self):
        return str(self.data)


class LinkedList:
    """单向链表"""
    
    def __init__(self):
        self.head = None
        self.size = 0
    
    def is_empty(self):
        """检查链表是否为空"""
        return self.head is None
    
    def append(self, data):
        """在链表末尾添加节点"""
        new_node = Node(data)
        
        if self.is_empty():
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node
        
        self.size += 1
    
    def prepend(self, data):
        """在链表开头添加节点"""
        new_node = Node(data)
        new_node.next = self.head
        self.head = new_node
        self.size += 1
    
    def insert(self, index, data):
        """在指定位置插入节点"""
        if index < 0 or index > self.size:
            raise IndexError("Index out of range")
        
        if index == 0:
            self.prepend(data)
            return
        
        new_node = Node(data)
        current = self.head
        for _ in range(index - 1):
            current = current.next
        
        new_node.next = current.next
        current.next = new_node
        self.size += 1
    
    def delete(self, data):
        """删除第一个匹配的节点"""
        if self.is_empty():
            raise ValueError("List is empty")
        
        # 如果要删除的是头节点
        if self.head.data == data:
            self.head = self.head.next
            self.size -= 1
            return
        
        # 查找要删除的节点
        current = self.head
        while current.next:
            if current.next.data == data:
                current.next = current.next.next
                self.size -= 1
                return
            current = current.next
        
        raise ValueError(f"Value {data} not found in list")
    
    def find(self, data):
        """查找节点"""
        current = self.head
        index = 0
        
        while current:
            if current.data == data:
                return index
            current = current.next
            index += 1
        
        return -1
    
    def get(self, index):
        """获取指定位置的节点"""
        if index < 0 or index >= self.size:
            raise IndexError("Index out of range")
        
        current = self.head
        for _ in range(index):
            current = current.next
        
        return current.data
    
    def reverse(self):
        """反转链表"""
        prev = None
        current = self.head
        
        while current:
            next_node = current.next
            current.next = prev
            prev = current
            current = next_node
        
        self.head = prev
    
    def __len__(self):
        return self.size
    
    def __str__(self):
        if self.is_empty():
            return "LinkedList([])"
        
        result = []
        current = self.head
        while current:
            result.append(str(current.data))
            current = current.next
        
        return f"LinkedList([{' -> '.join(result)}])"


# 使用链表
ll = LinkedList()
print(f"链表是否为空: {ll.is_empty()}")  # True

# 添加元素
ll.append(1)
ll.append(2)
ll.append(3)
print(ll)  # LinkedList([1 -> 2 -> 3])

# 在开头添加
ll.prepend(0)
print(ll)  # LinkedList([0 -> 1 -> 2 -> 3])

# 插入
ll.insert(2, 1.5)
print(ll)  # LinkedList([0 -> 1 -> 1.5 -> 2 -> 3])

# 查找
print(f"查找元素2: 索引 {ll.find(2)}")  # 3

# 获取元素
print(f"索引2的元素: {ll.get(2)}")  # 1.5

# 删除
ll.delete(1.5)
print(ll)  # LinkedList([0 -> 1 -> 2 -> 3])

# 反转
ll.reverse()
print(ll)  # LinkedList([3 -> 2 -> 1 -> 0])

print(f"链表长度: {len(ll)}")  # 4
```

------

### 5.4.3 Python实现双向链表

```
python复制class DNode:
    """双向链表节点"""
    def __init__(self, data):
        self.data = data
        self.prev = None
        self.next = None


class DoublyLinkedList:
    """双向链表"""
    
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    
    def is_empty(self):
        return self.head is None
    
    def append(self, data):
        """在末尾添加"""
        new_node = DNode(data)
        
        if self.is_empty():
            self.head = self.tail = new_node
        else:
            new_node.prev = self.tail
            self.tail.next = new_node
            self.tail = new_node
        
        self.size += 1
    
    def prepend(self, data):
        """在开头添加"""
        new_node = DNode(data)
        
        if self.is_empty():
            self.head = self.tail = new_node
        else:
            new_node.next = self.head
            self.head.prev = new_node
            self.head = new_node
        
        self.size += 1
    
    def delete(self, data):
        """删除节点"""
        if self.is_empty():
            raise ValueError("List is empty")
        
        current = self.head
        
        while current:
            if current.data == data:
                # 删除头节点
                if current == self.head:
                    self.head = current.next
                    if self.head:
                        self.head.prev = None
                    else:
                        self.tail = None
                # 删除尾节点
                elif current == self.tail:
                    self.tail = current.prev
                    self.tail.next = None
                # 删除中间节点
                else:
                    current.prev.next = current.next
                    current.next.prev = current.prev
                
                self.size -= 1
                return
            
            current = current.next
        
        raise ValueError(f"Value {data} not found in list")
    
    def __str__(self):
        if self.is_empty():
            return "DoublyLinkedList([])"
        
        result = []
        current = self.head
        while current:
            result.append(str(current.data))
            current = current.next
        
        return f"DoublyLinkedList([{' <-> '.join(result)}])"


# 使用双向链表
dll = DoublyLinkedList()
dll.append(1)
dll.append(2)
dll.append(3)
dll.prepend(0)
print(dll)  # DoublyLinkedList([0 <-> 1 <-> 2 <-> 3])

dll.delete(2)
print(dll)  # DoublyLinkedList([0 <-> 1 <-> 3])
```

------

### 5.4.4 Java实现链表

```
java复制class Node<T> {
    T data;
    Node<T> next;
    
    public Node(T data) {
        this.data = data;
        this.next = null;
    }
}

public class LinkedList<T> {
    private Node<T> head;
    private int size;
    
    public LinkedList() {
        this.head = null;
        this.size = 0;
    }
    
    public boolean isEmpty() {
        return head == null;
    }
    
    // 在末尾添加
    public void append(T data) {
        Node<T> newNode = new Node<>(data);
        
        if (isEmpty()) {
            head = newNode;
        } else {
            Node<T> current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
        size++;
    }
    
    // 在开头添加
    public void prepend(T data) {
        Node<T> newNode = new Node<>(data);
        newNode.next = head;
        head = newNode;
        size++;
    }
    
    // 删除节点
    public void delete(T data) {
        if (isEmpty()) {
            throw new IllegalStateException("List is empty");
        }
        
        // 删除头节点
        if (head.data.equals(data)) {
            head = head.next;
            size--;
            return;
        }
        
        // 查找并删除
        Node<T> current = head;
        while (current.next != null) {
            if (current.next.data.equals(data)) {
                current.next = current.next.next;
                size--;
                return;
            }
            current = current.next;
        }
        
        throw new IllegalArgumentException("Value not found");
    }
    
    // 查找
    public int find(T data) {
        Node<T> current = head;
        int index = 0;
        
        while (current != null) {
            if (current.data.equals(data)) {
                return index;
            }
            current = current.next;
            index++;
        }
        
        return -1;
    }
    
    public int size() {
        return size;
    }
    
    @Override
    public String toString() {
        if (isEmpty()) {
            return "LinkedList([])";
        }
        
        StringBuilder sb = new StringBuilder("LinkedList([");
        Node<T> current = head;
        
        while (current != null) {
            sb.append(current.data);
            if (current.next != null) {
                sb.append(" -> ");
            }
            current = current.next;
        }
        
        sb.append("])");
        return sb.toString();
    }
    
    // 测试
    public static void main(String[] args) {
        LinkedList<Integer> ll = new LinkedList<>();
        
        ll.append(1);
        ll.append(2);
        ll.append(3);
        ll.prepend(0);
        System.out.println(ll);  // LinkedList([0 -> 1 -> 2 -> 3])
        
        System.out.println("查找2: " + ll.find(2));  // 2
        
        ll.delete(2);
        System.out.println(ll);  // LinkedList([0 -> 1 -> 3])
        
        System.out.println("大小: " + ll.size());  // 3
    }
}
```

------

### 5.4.5 链表的经典问题

#### 问题1：检测链表是否有环

```
python复制def has_cycle(head):
    """
    使用快慢指针检测环
    快指针每次移动2步，慢指针每次移动1步
    如果有环，快慢指针最终会相遇
    """
    if not head or not head.next:
        return False
    
    slow = head
    fast = head.next
    
    while slow != fast:
        if not fast or not fast.next:
            return False
        slow = slow.next
        fast = fast.next.next
    
    return True
```

#### 问题2：找到链表的中间节点

```
python复制def find_middle(head):
    """
    使用快慢指针找中间节点
    快指针到达末尾时，慢指针在中间
    """
    if not head:
        return None
    
    slow = head
    fast = head
    
    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next
    
    return slow
```

#### 问题3：合并两个有序链表

```
python复制def merge_sorted_lists(l1, l2):
    """合并两个有序链表"""
    dummy = Node(0)
    current = dummy
    
    while l1 and l2:
        if l1.data <= l2.data:
            current.next = l1
            l1 = l1.next
        else:
            current.next = l2
            l2 = l2.next
        current = current.next
```

继续生成：

```
python复制    # 连接剩余节点
    if l1:
        current.next = l1
    if l2:
        current.next = l2
    
    return dummy.next
```

------

## 5.5 树（Tree） (35分钟)

### 5.5.1 树的概念

**树（Tree）**是一种非线性的层次数据结构，由节点组成。

```
diff复制树的基本术语：
         1          ← 根节点 (root)
       /   \
      2     3       ← 节点 (node)
     / \   / \
    4   5 6   7     ← 叶子节点 (leaf)
    
- 根节点：树的顶部节点
- 父节点：有子节点的节点
- 子节点：某节点的直接下级
- 叶子节点：没有子节点的节点
- 深度：从根到节点的路径长度
- 高度：从节点到最深叶子的路径长度
- 层级：根节点为第0层
```

------

### 5.5.2 二叉树（Binary Tree）

**二叉树**：每个节点最多有两个子节点（左子节点和右子节点）

```
markdown复制二叉树类型：

1. 完全二叉树：
         1
       /   \
      2     3
     / \   /
    4   5 6

2. 满二叉树：
         1
       /   \
      2     3
     / \   / \
    4   5 6   7

3. 二叉搜索树（BST）：
         5
       /   \
      3     8
     / \   / \
    1   4 6   9
    
左子树 < 根 < 右子树
```

------

### 5.5.3 Python实现二叉树

```
python复制class TreeNode:
    """树节点"""
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None
    
    def __str__(self):
        return str(self.value)


class BinaryTree:
    """二叉树"""
    
    def __init__(self, root_value=None):
        self.root = TreeNode(root_value) if root_value is not None else None
    
    def is_empty(self):
        """检查树是否为空"""
        return self.root is None
    
    # ==================== 遍历方法 ====================
    
    def preorder_traversal(self, node=None, result=None):
        """
        前序遍历：根 -> 左 -> 右
        """
        if result is None:
            result = []
        if node is None:
            node = self.root
        
        if node:
            result.append(node.value)
            self.preorder_traversal(node.left, result)
            self.preorder_traversal(node.right, result)
        
        return result
    
    def inorder_traversal(self, node=None, result=None):
        """
        中序遍历：左 -> 根 -> 右
        """
        if result is None:
            result = []
        if node is None:
            node = self.root
        
        if node:
            self.inorder_traversal(node.left, result)
            result.append(node.value)
            self.inorder_traversal(node.right, result)
        
        return result
    
    def postorder_traversal(self, node=None, result=None):
        """
        后序遍历：左 -> 右 -> 根
        """
        if result is None:
            result = []
        if node is None:
            node = self.root
        
        if node:
            self.postorder_traversal(node.left, result)
            self.postorder_traversal(node.right, result)
            result.append(node.value)
        
        return result
    
    def level_order_traversal(self):
        """
        层序遍历（广度优先）
        """
        if not self.root:
            return []
        
        result = []
        queue = Queue()
        queue.enqueue(self.root)
        
        while not queue.is_empty():
            node = queue.dequeue()
            result.append(node.value)
            
            if node.left:
                queue.enqueue(node.left)
            if node.right:
                queue.enqueue(node.right)
        
        return result
    
    # ==================== 树的属性 ====================
    
    def height(self, node=None):
        """计算树的高度"""
        if node is None:
            node = self.root
        
        if not node:
            return -1
        
        left_height = self.height(node.left)
        right_height = self.height(node.right)
        
        return max(left_height, right_height) + 1
    
    def count_nodes(self, node=None):
        """计算节点总数"""
        if node is None:
            node = self.root
        
        if not node:
            return 0
        
        return 1 + self.count_nodes(node.left) + self.count_nodes(node.right)
    
    def count_leaves(self, node=None):
        """计算叶子节点数"""
        if node is None:
            node = self.root
        
        if not node:
            return 0
        
        if not node.left and not node.right:
            return 1
        
        return self.count_leaves(node.left) + self.count_leaves(node.right)
    
    # ==================== 可视化 ====================
    
    def print_tree(self, node=None, level=0, prefix="Root: "):
        """打印树结构"""
        if node is None:
            node = self.root
        
        if node:
            print(" " * (level * 4) + prefix + str(node.value))
            if node.left or node.right:
                if node.left:
                    self.print_tree(node.left, level + 1, "L--- ")
                else:
                    print(" " * ((level + 1) * 4) + "L--- None")
                
                if node.right:
                    self.print_tree(node.right, level + 1, "R--- ")
                else:
                    print(" " * ((level + 1) * 4) + "R--- None")


# 创建二叉树
#         1
#       /   \
#      2     3
#     / \   / \
#    4   5 6   7

tree = BinaryTree(1)
tree.root.left = TreeNode(2)
tree.root.right = TreeNode(3)
tree.root.left.left = TreeNode(4)
tree.root.left.right = TreeNode(5)
tree.root.right.left = TreeNode(6)
tree.root.right.right = TreeNode(7)

# 打印树结构
print("树结构：")
tree.print_tree()

# 遍历
print("\n前序遍历:", tree.preorder_traversal())    # [1, 2, 4, 5, 3, 6, 7]
print("中序遍历:", tree.inorder_traversal())      # [4, 2, 5, 1, 6, 3, 7]
print("后序遍历:", tree.postorder_traversal())    # [4, 5, 2, 6, 7, 3, 1]
print("层序遍历:", tree.level_order_traversal())  # [1, 2, 3, 4, 5, 6, 7]

# 树的属性
print(f"\n树的高度: {tree.height()}")            # 2
print(f"节点总数: {tree.count_nodes()}")          # 7
print(f"叶子节点数: {tree.count_leaves()}")      # 4
```

------

### 5.5.4 二叉搜索树（BST）

```
python复制class BinarySearchTree:
    """二叉搜索树"""
    
    def __init__(self):
        self.root = None
    
    def insert(self, value):
        """插入节点"""
        if not self.root:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)
    
    def _insert_recursive(self, node, value):
        """递归插入"""
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert_recursive(node.left, value)
        elif value > node.value:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert_recursive(node.right, value)
        # 如果值相等，不插入（避免重复）
    
    def search(self, value):
        """搜索节点"""
        return self._search_recursive(self.root, value)
    
    def _search_recursive(self, node, value):
        """递归搜索"""
        if not node:
            return False
        
        if value == node.value:
            return True
        elif value < node.value:
            return self._search_recursive(node.left, value)
        else:
            return self._search_recursive(node.right, value)
    
    def find_min(self, node=None):
        """找到最小值节点"""
        if node is None:
            node = self.root
        
        if not node:
            return None
        
        while node.left:
            node = node.left
        
        return node.value
    
    def find_max(self, node=None):
        """找到最大值节点"""
        if node is None:
            node = self.root
        
        if not node:
            return None
        
        while node.right:
            node = node.right
        
        return node.value
    
    def delete(self, value):
        """删除节点"""
        self.root = self._delete_recursive(self.root, value)
    
    def _delete_recursive(self, node, value):
        """递归删除"""
        if not node:
            return None
        
        if value < node.value:
            node.left = self._delete_recursive(node.left, value)
        elif value > node.value:
            node.right = self._delete_recursive(node.right, value)
        else:
            # 找到要删除的节点
            
            # 情况1：叶子节点
            if not node.left and not node.right:
                return None
            
            # 情况2：只有一个子节点
            if not node.left:
                return node.right
            if not node.right:
                return node.left
            
            # 情况3：有两个子节点
            # 找到右子树的最小值（后继节点）
            min_value = self.find_min(node.right)
            node.value = min_value
            node.right = self._delete_recursive(node.right, min_value)
        
        return node
    
    def inorder_traversal(self, node=None, result=None):
        """中序遍历（有序输出）"""
        if result is None:
            result = []
        if node is None:
            node = self.root
        
        if node:
            self.inorder_traversal(node.left, result)
            result.append(node.value)
            self.inorder_traversal(node.right, result)
        
        return result
    
    def is_valid_bst(self, node=None, min_val=float('-inf'), max_val=float('inf')):
        """验证是否为有效的BST"""
        if node is None:
            node = self.root
        
        if not node:
            return True
        
        if node.value <= min_val or node.value >= max_val:
            return False
        
        return (self.is_valid_bst(node.left, min_val, node.value) and
                self.is_valid_bst(node.right, node.value, max_val))


# 使用二叉搜索树
bst = BinarySearchTree()

# 插入节点
values = [5, 3, 7, 1, 4, 6, 9]
for val in values:
    bst.insert(val)

print("BST结构：")
#         5
#       /   \
#      3     7
#     / \   / \
#    1   4 6   9

# 中序遍历（有序输出）
print("中序遍历:", bst.inorder_traversal())  # [1, 3, 4, 5, 6, 7, 9]

# 搜索
print(f"\n搜索4: {bst.search(4)}")  # True
print(f"搜索8: {bst.search(8)}")    # False

# 最小值和最大值
print(f"\n最小值: {bst.find_min()}")  # 1
print(f"最大值: {bst.find_max()}")    # 9

# 验证BST
print(f"\n是否为有效BST: {bst.is_valid_bst()}")  # True

# 删除节点
bst.delete(3)
print(f"\n删除3后的中序遍历: {bst.inorder_traversal()}")  # [1, 4, 5, 6, 7, 9]
```

------

### 5.5.5 Java实现二叉搜索树

```
java复制class TreeNode {
    int value;
    TreeNode left;
    TreeNode right;
    
    public TreeNode(int value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

public class BinarySearchTree {
    private TreeNode root;
    
    public BinarySearchTree() {
        this.root = null;
    }
    
    // 插入
    public void insert(int value) {
        root = insertRecursive(root, value);
    }
    
    private TreeNode insertRecursive(TreeNode node, int value) {
        if (node == null) {
            return new TreeNode(value);
        }
        
        if (value < node.value) {
            node.left = insertRecursive(node.left, value);
        } else if (value > node.value) {
            node.right = insertRecursive(node.right, value);
        }
        
        return node;
    }
    
    // 搜索
    public boolean search(int value) {
        return searchRecursive(root, value);
    }
    
    private boolean searchRecursive(TreeNode node, int value) {
        if (node == null) {
            return false;
        }
        
        if (value == node.value) {
            return true;
        } else if (value < node.value) {
            return searchRecursive(node.left, value);
        } else {
            return searchRecursive(node.right, value);
        }
    }
    
    // 中序遍历
    public void inorderTraversal() {
        inorderRecursive(root);
        System.out.println();
    }
    
    private void inorderRecursive(TreeNode node) {
        if (node != null) {
            inorderRecursive(node.left);
            System.out.print(node.value + " ");
            inorderRecursive(node.right);
        }
    }
    
    // 测试
    public static void main(String[] args) {
        BinarySearchTree bst = new BinarySearchTree();
        
        int[] values = {5, 3, 7, 1, 4, 6, 9};
        for (int val : values) {
            bst.insert(val);
        }
        
        System.out.print("中序遍历: ");
        bst.inorderTraversal();  // 1 3 4 5 6 7 9
        
        System.out.println("搜索4: " + bst.search(4));  // true
        System.out.println("搜索8: " + bst.search(8));  // false
    }
}
```

------

### 5.5.6 树的应用场景

1. **文件系统**：目录结构
2. **HTML DOM**：网页元素层次
3. **数据库索引**：B树、B+树
4. **决策树**：机器学习
5. **表达式树**：编译器
6. **Huffman编码**：数据压缩

------

## 5.6 哈希表（Hash Table） (25分钟)

### 5.6.1 哈希表的概念

**哈希表（Hash Table）**通过哈希函数将键映射到数组索引，实现快速查找。

```
bash复制哈希表原理：
    Key → Hash Function → Index → Value
    
    "apple"  → hash("apple") % 10 → 3 → "red"
    "banana" → hash("banana") % 10 → 7 → "yellow"
    
数组表示：
    Index: 0    1    2    3       4    5    6    7          8    9
    Value: -    -    -    "red"   -    -    -    "yellow"   -    -
```

**哈希冲突**：不同的键映射到相同的索引

**解决方法：**

1. **链地址法（Chaining）**：每个索引存储一个链表
2. **开放地址法（Open Addressing）**：寻找下一个空位置

------

### 5.6.2 Python实现哈希表（链地址法）

```
python复制class HashTable:
    """哈希表实现（链地址法）"""
    
    def __init__(self, capacity=10):
        self.capacity = capacity
        self.size = 0
        self.buckets = [[] for _ in range(capacity)]
    
    def _hash(self, key):
        """哈希函数"""
        return hash(key) % self.capacity
    
    def put(self, key, value):
        """插入或更新键值对"""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        # 检查键是否已存在
        for i, (k, v) in enumerate(bucket):
            if k == key:
                bucket[i] = (key, value)  # 更新
                return
        
        # 键不存在，添加新项
        bucket.append((key, value))
        self.size += 1
        
        # 检查负载因子，必要时扩容
        if self.size / self.capacity > 0.7:
            self._resize()
    
    def get(self, key):
        """获取值"""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for k, v in bucket:
            if k == key:
                return v
        
        raise KeyError(f"Key '{key}' not found")
    
    def remove(self, key):
        """删除键值对"""
        index = self._hash(key)
        bucket = self.buckets[index]
        
        for i, (k, v) in enumerate(bucket):
            if k == key:
                del bucket[i]
                self.size -= 1
                return
        
        raise KeyError(f"Key '{key}' not found")
    
    def contains(self, key):
        """检查键是否存在"""
        try:
            self.get(key)
            return True
        except KeyError:
            return False
    
    def _resize(self):
        """扩容"""
        old_buckets = self.buckets
        self.capacity *= 2
        self.buckets = [[] for _ in range(self.capacity)]
        self.size = 0
        
        # 重新插入所有元素
        for bucket in old_buckets:
            for key, value in bucket:
                self.put(key, value)
    
    def keys(self):
        """返回所有键"""
        result = []
        for bucket in self.buckets:
            for key, value in bucket:
                result.append(key)
        return result
    
    def values(self):
        """返回所有值"""
        result = []
        for bucket in self.buckets:
            for key, value in bucket:
                result.append(value)
        return result
    
    def items(self):
        """返回所有键值对"""
        result = []
        for bucket in self.buckets:
            for item in bucket:
                result.append(item)
        return result
    
    def __len__(self):
        return self.size
    
    def __str__(self):
        items = self.items()
        return f"HashTable({dict(items)})"


# 使用哈希表
ht = HashTable()

# 插入
ht.put("apple", "red")
ht.put("banana", "yellow")
ht.put("grape", "purple")
ht.put("orange", "orange")

print(ht)  # HashTable({'apple': 'red', 'banana': 'yellow', ...})

# 获取
print(f"apple的颜色: {ht.get('apple')}")  # red

# 更新
ht.put("apple", "green")
print(f"apple的新颜色: {ht.get('apple')}")  # green

# 检查
print(f"包含banana: {ht.contains('banana')}")  # True
print(f"包含cherry: {ht.contains('cherry')}")  # False

# 删除
ht.remove("banana")
print(f"删除后包含banana: {ht.contains('banana')}")  # False

# 遍历
print(f"\n所有键: {ht.keys()}")
print(f"所有值: {ht.values()}")
print(f"大小: {len(ht)}")
```

------

### 5.6.3 哈希表的应用

#### 应用1：单词频率统计

```
python复制def word_frequency(text):
    """统计单词频率"""
    # 使用Python内置字典（基于哈希表）
    frequency = {}
    
    words = text.lower().split()
    
    for word in words:
        # 移除标点符号
        word = word.strip('.,!?;:"\'')
        if word:
            frequency[word] = frequency.get(word, 0) + 1
    
    return frequency


text = """
Python is a great programming language. 
Python is easy to learn. 
Programming in Python is fun.
"""

freq = word_frequency(text)
print("单词频率:")
for word, count in sorted(freq.items(), key=lambda x: x[1], reverse=True):
    print(f"  {word}: {count}")
```

#### 应用2：两数之和（LeetCode经典题）

```
python复制def two_sum(nums, target):
    """
    找到数组中两个数，使其和等于目标值
    返回这两个数的索引
    """
    seen = {}  # 哈希表：值 -> 索引
    
    for i, num in enumerate(nums):
        complement = target - num
        
        if complement in seen:
            return [seen[complement], i]
        
        seen[num] = i
    
    return None


# 测试
nums = [2, 7, 11, 15]
target = 9
result = two_sum(nums, target)
print(f"两数之和: {result}")  # [0, 1]
print(f"验证: {nums[result[0]]} + {nums[result[1]]} = {target}")
```

#### 应用3：LRU缓存

```
python复制from collections import OrderedDict

class LRUCache:
    """最近最少使用缓存"""
    
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity
    
    def get(self, key):
        """获取值"""
        if key not in self.cache:
            return -1
        
        # 移动到末尾（最近使用）
        self.cache.move_to_end(key)
        return self.cache[key]
    
    def put(self, key, value):
        """插入或更新"""
        if key in self.cache:
            # 更新并移动到末尾
            self.cache.move_to_end(key)
        
        self.cache[key] = value
        
        # 如果超过容量，删除最久未使用的（开头）
        if len(self.cache) > self.capacity:
            self.cache.popitem(last=False)
    
    def __str__(self):
        return f"LRUCache({dict(self.cache)})"


# 使用LRU缓存
cache = LRUCache(3)

cache.put(1, "one")
cache.put(2, "two")
cache.put(3, "three")
print(cache)  # LRUCache({1: 'one', 2: 'two', 3: 'three'})

cache.get(1)  # 访问1，移到最后
cache.put(4, "four")  # 添加4，删除最久未使用的2
print(cache)  # LRUCache({3: 'three', 1: 'one', 4: 'four'})
```

------

## 5.7 算法复杂度分析 (20分钟)

### 5.7.1 时间复杂度

**时间复杂度**表示算法执行时间随输入规模增长的趋势。

```
scss复制常见时间复杂度（从快到慢）：
O(1)        < O(log n)  < O(n)      < O(n log n) < O(n²)     < O(2^n)    < O(n!)
常数时间      对数时间     线性时间     线性对数时间   平方时间      指数时间     阶乘时间

示例：
O(1):       访问数组元素
O(log n):   二分查找
O(n):       遍历数组
O(n log n): 归并排序、快速排序
O(n²):      冒泡排序、选择排序
O(2^n):     递归计算斐波那契数列
O(n!):      旅行商问题（暴力解法）
```

------

### 5.7.2 复杂度示例

```
python复制# O(1) - 常数时间
def get_first_element(arr):
    return arr[0]  # 无论数组多大，都是一次操作


# O(n) - 线性时间
def find_max(arr):
    max_val = arr[0]
    for num in arr:  # 遍历n个元素
        if num > max_val:
            max_val = num
    return max_val


# O(log n) - 对数时间
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return -1


# O(n log n) - 线性对数时间
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])    # log n 层递归
    right = merge_sort(arr[mid:])
    
    return merge(left, right)  # 每层O(n)合并

def merge(left, right):
    result = []
    i = j = 0
    
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    result.extend(left[i:])
    result.extend(right[j:])
    return result


# O(n²) - 平方时间
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):          # 外层循环n次
        for j in range(n - i - 1):  # 内层循环n次
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr


# O(2^n) - 指数时间
def fibonacci_recursive(n):
    if n <= 1:
        return n
    return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)


# 优化为O(n) - 使用动态规划
def fibonacci_dp(n):
    if n <= 1:
        return n
    
    dp = [0] * (n + 1)
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]


# 测试和比较
import time

def measure_time(func, *args):
    start = time.time()
    result = func(*args)
    end = time.time()
    return result, end - start

# 比较斐波那契算法
n = 30
result1, time1 = measure_time(fibonacci_recursive, n)
result2, time2 = measure_time(fibonacci_dp, n)

print(f"递归方法: 结果={result1}, 时间={time1:.4f}秒")
print(f"动态规划: 结果={result2}, 时间={time2:.6f}秒")
print(f"速度提升: {time1/time2:.0f}倍")
```

------

### 5.7.3 空间复杂度

**空间复杂度**表示算法执行过程中所需的额外内存空间。

```
python复制# O(1) - 常数空间
def sum_array(arr):
    total = 0  # 只使用一个变量
    for num in arr:
        total += num
    return total


# O(n) - 线性空间
def reverse_array(arr):
    return arr[::-1]  # 创建新数组，大小为n


# O(n) - 递归调用栈
def factorial_recursive(n):
    """
    递归深度为n，调用栈占用O(n)空间
    """
    if n <= 1:
        return 1
    return n * factorial_recursive(n - 1)


# O(1) - 迭代版本
def factorial_iterative(n):
    """
    只使用常数个变量
    """
    result = 1
    for i in range(2, n + 1):
        result *= i
    return result


# O(n²) - 二维数组
def create_matrix(n):
    """
    创建n×n矩阵，空间复杂度O(n²)
    """
    return [[0] * n for _ in range(n)]


# 空间优化示例：原地算法
def reverse_in_place(arr):
    """
    原地反转数组，空间复杂度O(1)
    """
    left, right = 0, len(arr) - 1
    while left < right:
        arr[left], arr[right] = arr[right], arr[left]
        left += 1
        right -= 1
    return arr


# 测试
arr = [1, 2, 3, 4, 5]
print(f"原数组: {arr}")
reverse_in_place(arr)
print(f"反转后: {arr}")
```

------

### 5.7.4 复杂度对比表

| 算法         | 最好       | 平均       | 最坏       | 空间     |
| ------------ | ---------- | ---------- | ---------- | -------- |
| **冒泡排序** | O(n)       | O(n²)      | O(n²)      | O(1)     |
| **选择排序** | O(n²)      | O(n²)      | O(n²)      | O(1)     |
| **插入排序** | O(n)       | O(n²)      | O(n²)      | O(1)     |
| **归并排序** | O(n log n) | O(n log n) | O(n log n) | O(n)     |
| **快速排序** | O(n log n) | O(n log n) | O(n²)      | O(log n) |
| **堆排序**   | O(n log n) | O(n log n) | O(n log n) | O(1)     |
| **二分查找** | O(1)       | O(log n)   | O(log n)   | O(1)     |
| **线性查找** | O(1)       | O(n)       | O(n)       | O(1)     |

------

### 5.7.5 如何分析复杂度

```
python复制def analyze_complexity():
    """
    复杂度分析步骤：
    1. 找出基本操作（通常是最内层循环）
    2. 计算基本操作执行次数
    3. 用大O表示法简化
    """
    pass

# 示例1：单层循环
def example1(n):
    for i in range(n):      # 执行n次
        print(i)            # O(1)操作
    # 总复杂度：O(n)


# 示例2：嵌套循环
def example2(n):
    for i in range(n):          # 外层n次
        for j in range(n):      # 内层n次
            print(i, j)         # O(1)操作
    # 总复杂度：O(n) × O(n) = O(n²)


# 示例3：循环次数减半
def example3(n):
    i = n
    while i > 0:
        print(i)
        i = i // 2          # 每次减半
    # 执行次数：log₂(n)
    # 总复杂度：O(log n)


# 示例4：多个独立循环
def example4(n):
    for i in range(n):      # O(n)
        print(i)
    
    for j in range(n):      # O(n)
        print(j)
    
    for k in range(n):      # O(n)
        print(k)
    
    # 总复杂度：O(n) + O(n) + O(n) = O(3n) = O(n)


# 示例5：不同规模的嵌套
def example5(n, m):
    for i in range(n):      # n次
        for j in range(m):  # m次
            print(i, j)
    # 总复杂度：O(n × m)


# 示例6：递归分析
def example6(n):
    if n <= 1:
        return 1
    return example6(n // 2) + example6(n // 2)
    # 递归树深度：log n
    # 每层节点数：2^层数
    # 总复杂度：O(n)
```

------

## 5.8 实战项目：任务调度系统 (40分钟)

### 5.8.1 项目需求

创建一个任务调度系统，支持：

1. 添加任务（带优先级）
2. 执行最高优先级任务
3. 查看待处理任务
4. 任务历史记录
5. 统计信息

------

### 5.8.2 完整实现

```python
import time
from datetime import datetime
from collections import deque
import heapq


class Task:
    """任务类"""
    
    # 任务状态
    PENDING = "待处理"
    RUNNING = "执行中"
    COMPLETED = "已完成"
    FAILED = "失败"
    
    def __init__(self, task_id, name, priority=0, duration=1):
        self.task_id = task_id
        self.name = name
        self.priority = priority  # 优先级（数字越大优先级越高）
        self.duration = duration  # 预计执行时间（秒）
        self.status = Task.PENDING
        self.created_at = datetime.now()
        self.started_at = None
        self.completed_at = None
        self.result = None
    
    def __lt__(self, other):
        """用于优先队列比较（优先级高的在前）"""
        return self.priority > other.priority
    
    def execute(self):
        """执行任务"""
        self.status = Task.RUNNING
        self.started_at = datetime.now()
        
        print(f"[{self.started_at.strftime('%H:%M:%S')}] 开始执行任务: {self.name}")
        
        try:
            # 模拟任务执行
            time.sleep(self.duration)
            
            self.status = Task.COMPLETED
            self.completed_at = datetime.now()
            self.result = f"任务 {self.name} 成功完成"
            
            print(f"[{self.completed_at.strftime('%H:%M:%S')}] 完成任务: {self.name}")
            return True
            
        except Exception as e:
            self.status = Task.FAILED
            self.completed_at = datetime.now()
            self.result = f"任务失败: {str(e)}"
            print(f"[{self.completed_at.strftime('%H:%M:%S')}] 任务失败: {self.name}")
            return False
    
    def __str__(self):
        return (f"Task(id={self.task_id}, name='{self.name}', "
                f"priority={self.priority}, status={self.status})")
    
    def get_info(self):
        """获取任务详细信息"""
        info = {
            'ID': self.task_id,
            '名称': self.name,
            '优先级': self.priority,
            '状态': self.status,
            '创建时间': self.created_at.strftime('%Y-%m-%d %H:%M:%S'),
        }
        
        if self.started_at:
            info['开始时间'] = self.started_at.strftime('%Y-%m-%d %H:%M:%S')
        
        if self.completed_at:
            info['完成时间'] = self.completed_at.strftime('%Y-%m-%d %H:%M:%S')
            elapsed = (self.completed_at - self.started_at).total_seconds()
            info['执行时长'] = f"{elapsed:.2f}秒"
        
        if self.result:
            info['结果'] = self.result
        
        return info


class TaskScheduler:
    """任务调度器"""
    
    def __init__(self):
        self.task_queue = []  # 优先队列（最小堆）
        self.history = deque(maxlen=100)  # 历史记录（最多保存100条）
        self.task_counter = 0
        self.stats = {
            'total_tasks': 0,
            'completed_tasks': 0,
            'failed_tasks': 0,
            'total_execution_time': 0
        }
    
    def add_task(self, name, priority=0, duration=1):
        """添加任务"""
        self.task_counter += 1
        task = Task(self.task_counter, name, priority, duration)
        heapq.heappush(self.task_queue, task)
        self.stats['total_tasks'] += 1
        
        print(f"✓ 添加任务: {task}")
        return task
    
    def execute_next(self):
        """执行下一个最高优先级任务"""
        if not self.task_queue:
            print("⚠ 没有待处理的任务")
            return None
        
        task = heapq.heappop(self.task_queue)
        success = task.execute()
        
        # 更新统计信息
        if success:
            self.stats['completed_tasks'] += 1
        else:
            self.stats['failed_tasks'] += 1
        
        if task.started_at and task.completed_at:
            elapsed = (task.completed_at - task.started_at).total_seconds()
            self.stats['total_execution_time'] += elapsed
        
        # 添加到历史记录
        self.history.append(task)
        
        return task
    
    def execute_all(self):
        """执行所有待处理任务"""
        print("\n" + "="*60)
        print("开始执行所有任务...")
        print("="*60 + "\n")
        
        while self.task_queue:
            self.execute_next()
            print()  # 空行分隔
        
        print("="*60)
        print("所有任务执行完毕！")
        print("="*60 + "\n")
    
    def show_pending_tasks(self):
        """显示待处理任务"""
        if not self.task_queue:
            print("没有待处理的任务")
            return
        
        print("\n待处理任务列表：")
        print("-" * 60)
        
        # 复制队列并排序（不影响原队列）
        tasks = sorted(self.task_queue, reverse=True)
        
        for i, task in enumerate(tasks, 1):
            print(f"{i}. {task.name}")
            print(f"   优先级: {task.priority} | 预计时长: {task.duration}秒")
            print(f"   创建时间: {task.created_at.strftime('%H:%M:%S')}")
            print()
    
    def show_history(self, limit=10):
        """显示历史记录"""
        if not self.history:
            print("没有历史记录")
            return
        
        print(f"\n最近 {min(limit, len(self.history))} 条历史记录：")
        print("-" * 60)
        
        for task in list(self.history)[-limit:]:
            info = task.get_info()
            print(f"任务 #{info['ID']}: {info['名称']}")
            print(f"  状态: {info['状态']} | 优先级: {info['优先级']}")
            if '执行时长' in info:
                print(f"  执行时长: {info['执行时长']}")
            print()
    
    def show_statistics(self):
        """显示统计信息"""
        print("\n统计信息：")
        print("="*60)
        print(f"总任务数: {self.stats['total_tasks']}")
        print(f"已完成: {self.stats['completed_tasks']}")
        print(f"失败: {self.stats['failed_tasks']}")
        print(f"待处理: {len(self.task_queue)}")
        
        if self.stats['completed_tasks'] > 0:
            avg_time = self.stats['total_execution_time'] / self.stats['completed_tasks']
            print(f"平均执行时间: {avg_time:.2f}秒")
        
        if self.stats['total_tasks'] > 0:
            completion_rate = (self.stats['completed_tasks'] / 
                             self.stats['total_tasks'] * 100)
            print(f"完成率: {completion_rate:.1f}%")
        
        print("="*60 + "\n")
    
    def clear_history(self):
        """清空历史记录"""
        self.history.clear()
        print("✓ 历史记录已清空")
    
    def get_task_by_id(self, task_id):
        """根据ID查找任务"""
        # 在待处理队列中查找
        for task in self.task_queue:
            if task.task_id == task_id:
                return task
        
        # 在历史记录中查找
        for task in self.history:
            if task.task_id == task_id:
                return task
        
        return None


# ==================== 使用示例 ====================

def demo_basic_usage():
    """基本使用演示"""
    print("\n" + "="*60)
    print("任务调度系统 - 基本使用演示")
    print("="*60 + "\n")
    
    scheduler = TaskScheduler()
    
    # 添加任务
    scheduler.add_task("发送邮件", priority=3, duration=0.5)
    scheduler.add_task("生成报告", priority=5, duration=1)
    scheduler.add_task("备份数据", priority=1, duration=0.8)
    scheduler.add_task("更新数据库", priority=4, duration=0.6)
    scheduler.add_task("清理缓存", priority=2, duration=0.3)
    
    print()
    
    # 显示待处理任务
    scheduler.show_pending_tasks()
    
    # 执行所有任务
    scheduler.execute_all()
    
    # 显示历史记录
    scheduler.show_history()
    
    # 显示统计信息
    scheduler.show_statistics()


def demo_interactive():
    """交互式演示"""
    print("\n" + "="*60)
    print("任务调度系统 - 交互式演示")
    print("="*60 + "\n")
    
    scheduler = TaskScheduler()
    
    while True:
        print("\n请选择操作：")
        print("1. 添加任务")
        print("2. 执行下一个任务")
        print("3. 执行所有任务")
        print("4. 查看待处理任务")
        print("5. 查看历史记录")
        print("6. 查看统计信息")
        print("7. 清空历史记录")
        print("0. 退出")
        
        choice = input("\n请输入选项 (0-7): ").strip()
        
        if choice == '1':
            name = input("任务名称: ").strip()
            try:
                priority = int(input("优先级 (0-10): ").strip())
                duration = float(input("预计时长(秒): ").strip())
                scheduler.add_task(name, priority, duration)
            except ValueError:
                print("⚠ 输入格式错误")
        
        elif choice == '2':
            scheduler.execute_next()
        
        elif choice == '3':
            scheduler.execute_all()
        
        elif choice == '4':
            scheduler.show_pending_tasks()
        
        elif choice == '5':
            scheduler.show_history()
        
        elif choice == '6':
            scheduler.show_statistics()
        
        elif choice == '7':
            scheduler.clear_history()
        
        elif choice == '0':
            print("\n感谢使用！再见！")
            break
        
        else:
            print("⚠ 无效选项，请重新输入")


def demo_advanced():
    """高级功能演示"""
    print("\n" + "="*60)
    print("任务调度系统 - 高级功能演示")
    print("="*60 + "\n")
    
    scheduler = TaskScheduler()
    
    # 批量添加任务
    tasks_data = [
        ("数据采集", 8, 0.5),
        ("数据清洗", 7, 0.8),
        ("数据分析", 6, 1.2),
        ("生成图表", 5, 0.6),
        ("发送报告", 9, 0.4),
        ("归档数据", 3, 0.7),
    ]
    
    print("批量添加任务...")
    for name, priority, duration in tasks_data:
        scheduler.add_task(name, priority, duration)
    
    print()
    
    # 显示任务队列
    scheduler.show_pending_tasks()
    
    # 逐个执行并显示进度
    total = len(scheduler.task_queue)
    print(f"\n开始执行 {total} 个任务...\n")
    
    for i in range(total):
        print(f"进度: {i+1}/{total}")
        scheduler.execute_next()
        print()
    
    # 最终统计
    scheduler.show_statistics()
    scheduler.show_history()


# ==================== 运行演示 ====================

if __name__ == "__main__":
    # 运行基本演示
    demo_basic_usage()
    
    # 运行高级演示
    # demo_advanced()
    
    # 运行交互式演示（取消注释以使用）
    # demo_interactive()
```

------

### 5.8.3 项目扩展建议

```python
# 扩展1：任务依赖关系
class DependentTask(Task):
    """支持依赖关系的任务"""
    def __init__(self, task_id, name, priority=0, duration=1, dependencies=None):
        super().__init__(task_id, name, priority, duration)
        self.dependencies = dependencies or []  # 依赖的任务ID列表
    
    def can_execute(self, completed_tasks):
        """检查是否可以执行（所有依赖任务已完成）"""
        return all(dep_id in completed_tasks for dep_id in self.dependencies)


# 扩展2：定时任务
from datetime import datetime, timedelta

class ScheduledTask(Task):
    """定时任务"""
    def __init__(self, task_id, name, priority=0, duration=1, scheduled_time=None):
        super().__init__(task_id, name, priority, duration)
        self.scheduled_time = scheduled_time or datetime.now()
    
    def is_ready(self):
        """检查是否到达执行时间"""
        return datetime.now() >= self.scheduled_time


# 扩展3：重试机制
class RetryableTask(Task):
    """支持重试的任务"""
    def __init__(self, task_id, name, priority=0, duration=1, max_retries=3):
        super().__init__(task_id, name, priority, duration)
        self.max_retries = max_retries
        self.retry_count = 0
    
    def execute(self):
        """执行任务（支持重试）"""
        while self.retry_count < self.max_retries:
            try:
                return super().execute()
            except Exception as e:
                self.retry_count += 1
                if self.retry_count >= self.max_retries:
                    self.status = Task.FAILED
                    return False
                print(f"任务失败，重试 {self.retry_count}/{self.max_retries}...")


# 扩展4：任务分组
class TaskGroup:
    """任务组"""
    def __init__(self, name):
        self.name = name
        self.tasks = []
    
    def add_task(self, task):
        self.tasks.append(task)
    
    def execute_all(self):
        """执行组内所有任务"""
        for task in self.tasks:
            task.execute()
```

------

## 📚 课程总结

### 本节课学到了什么？

✅ **栈（Stack）**

- 后进先出（LIFO）
- 应用：括号匹配、表达式求值、函数调用栈

✅ **队列（Queue）**

- 先进先出（FIFO）
- 应用：BFS、打印队列、任务调度

✅ **链表（Linked List）**

- 动态大小、高效插入删除
- 单向链表、双向链表

✅ **树（Tree）**

- 层次结构
- 二叉树、二叉搜索树
- 遍历：前序、中序、后序、层序

✅ **哈希表（Hash Table）**

- O(1)查找、插入、删除
- 哈希冲突解决

✅ **算法复杂度**

- 时间复杂度：O(1), O(log n), O(n), O(n log n), O(n²)
- 空间复杂度分析

✅ **实战项目**

- 任务调度系统
- 综合运用多种数据结构

------

## 🎯 课后作业

### 作业1：实现栈的最小值功能 ⭐⭐⭐

设计一个栈，支持push、pop、top操作，并能在O(1)时间内获取栈中最小元素。

```python
class MinStack:
    def __init__(self):
        # TODO: 实现初始化
        pass
    
    def push(self, val):
        # TODO: 压栈
        pass
    
    def pop(self):
        # TODO: 出栈
        pass
    
    def top(self):
        # TODO: 获取栈顶元素
        pass
    
    def get_min(self):
        # TODO: 获取最小值（O(1)时间）
        pass
```

### 作业2：用队列实现栈 ⭐⭐⭐

使用两个队列实现栈的功能。

```python
class StackUsingQueues:
    def __init__(self):
        # TODO: 使用两个队列
        pass
    
    def push(self, x):
        # TODO: 实现压栈
        pass
    
    def pop(self):
        # TODO: 实现出栈
        pass
```

### 作业3：反转链表 ⭐⭐⭐

实现链表的反转（迭代和递归两种方法）。

```python
def reverse_list_iterative(head):
    # TODO: 迭代方法反转链表
    pass

def reverse_list_recursive(head):
    # TODO: 递归方法反转链表
    pass
```

### 作业4：验证二叉搜索树 ⭐⭐⭐⭐

判断一棵二叉树是否为有效的二叉搜索树。

```python
def is_valid_bst(root):
    # TODO: 验证BST
    pass
```

### 作业5：实现LFU缓存 ⭐⭐⭐⭐⭐

设计并实现最不经常使用（LFU）缓存。

```python
class LFUCache:
    def __init__(self, capacity):
        # TODO: 实现初始化
        pass
    
    def get(self, key):
        # TODO: 获取值并更新频率
        pass
    
    def put(self, key, value):
        # TODO: 插入/更新并管理频率
        pass
```

------

## 🎓 下节预告

**第六课：算法设计与优化**

- 排序算法详解
- 搜索算法
- 动态规划入门
- 贪心算法
- 分治算法
- 回溯算法
- 实战：解决经典算法问题

------

## ❓ 常见问题（FAQ）

**Q1: 什么时候使用栈，什么时候使用队列？**

A:

- **栈**：需要后进先出的场景（撤销操作、括号匹配、DFS）
- **队列**：需要先进先出的场景（BFS、任务调度、消息队列）

**Q2: 链表和数组如何选择？**

A:

- **数组**：需要随机访问、内存连续
- **链表**：频繁插入删除、大小不固定

**Q3: 为什么BST查找是O(log n)？**

A: 每次比较可以排除一半节点，类似二分查找。但如果树不平衡（退化成链表），最坏情况是O(n)。

**Q4: 哈希表的负载因子是什么？**

A: 负载因子 = 元素数量 / 桶数量。通常保持在0.7以下以减少冲突。

**Q5: 如何选择合适的数据结构？**

A: 考虑以下因素：

- 操作类型（查找、插入、删除）
- 操作频率
- 数据规模
- 内存限制
- 是否需要有序

------

## 💻 练习答案提示

### 作业1提示：MinStack

```python
class MinStack:
    def __init__(self):
        self.stack = []
        self.min_stack = []  # 辅助栈存储最小值
    
    def push(self, val):
        self.stack.append(val)
        if not self.min_stack or val <= self.min_stack[-1]:
            self.min_stack.append(val)
    
    def pop(self):
        val = self.stack.pop()
        if val == self.min_stack[-1]:
            self.min_stack.pop()
        return val
    
    def get_min(self):
        return self.min_stack[-1]
```

### 作业3提示：反转链表

```python
def reverse_list_iterative(head):
    prev = None
    current = head
    
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    
    return prev

def reverse_list_recursive(head):
    if not head or not head.next:
        return head
    
    new_head = reverse_list_recursive(head.next)
    head.next.next = head
    head.next = None
    
    return new_head
```

------

**恭喜你完成第五课！** 🎉

数据结构是编程的基础，掌握它们将大大提升你的编程能力。继续练习，多做题目，你会越来越熟练！

**记住：数据结构 + 算法 = 程序！** 💪

------

*课程结束时间：预计200分钟*
 *建议分2-3次学习，每次专注1-2个数据结构*