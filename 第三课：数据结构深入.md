# 第三课：数据结构深入

**课程时长：150分钟**
 **难度等级：⭐⭐⭐☆☆**

------

## 课程目标

通过本课学习，你将能够：

1. 掌握Python和Java中的核心数据结构
2. 理解不同数据结构的使用场景和性能特点
3. 熟练运用列表、字典、集合等进行数据操作
4. 学会选择合适的数据结构解决实际问题
5. 完成一个综合实战项目：通讯录管理系统

------

## 3.1 列表/数组 (35分钟)

### 3.1.1 基础操作

#### Python列表（List）

```python
# ========== 创建列表 ==========

# 空列表
empty_list = []
empty_list2 = list()

# 初始化列表
numbers = [1, 2, 3, 4, 5]
fruits = ["apple", "banana", "cherry"]
mixed = [1, "hello", 3.14, True]  # 可以混合类型

# 列表推导式创建
squares = [x**2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 重复创建
zeros = [0] * 5
print(zeros)  # [0, 0, 0, 0, 0]

# ========== 访问元素 ==========

fruits = ["apple", "banana", "cherry", "date", "elderberry"]

# 正向索引
print(fruits[0])    # "apple"（第一个）
print(fruits[2])    # "cherry"

# 负向索引（从后往前）
print(fruits[-1])   # "elderberry"（最后一个）
print(fruits[-2])   # "date"（倒数第二个）

# 切片操作
print(fruits[1:4])      # ['banana', 'cherry', 'date']
print(fruits[:3])       # ['apple', 'banana', 'cherry']（前3个）
print(fruits[2:])       # ['cherry', 'date', 'elderberry']（从索引2到末尾）
print(fruits[-3:])      # ['cherry', 'date', 'elderberry']（最后3个）
print(fruits[::2])      # ['apple', 'cherry', 'elderberry']（每隔一个）
print(fruits[::-1])     # 反转列表

# ========== 修改元素 ==========

fruits[1] = "blueberry"
print(fruits)  # ['apple', 'blueberry', 'cherry', 'date', 'elderberry']

# 修改切片
fruits[1:3] = ["kiwi", "mango"]
print(fruits)  # ['apple', 'kiwi', 'mango', 'date', 'elderberry']

# ========== 添加元素 ==========

numbers = [1, 2, 3]

# append：末尾添加单个元素
numbers.append(4)
print(numbers)  # [1, 2, 3, 4]

# insert：指定位置插入
numbers.insert(0, 0)  # 在索引0处插入0
print(numbers)  # [0, 1, 2, 3, 4]

# extend：添加多个元素
numbers.extend([5, 6, 7])
print(numbers)  # [0, 1, 2, 3, 4, 5, 6, 7]

# + 运算符：连接列表
new_list = numbers + [8, 9]
print(new_list)  # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# ========== 删除元素 ==========

fruits = ["apple", "banana", "cherry", "date"]

# remove：删除指定值（第一个匹配）
fruits.remove("banana")
print(fruits)  # ['apple', 'cherry', 'date']

# pop：删除指定索引（默认最后一个）
last = fruits.pop()
print(last)     # "date"
print(fruits)   # ['apple', 'cherry']

first = fruits.pop(0)
print(first)    # "apple"
print(fruits)   # ['cherry']

# del：删除指定索引或切片
numbers = [0, 1, 2, 3, 4, 5]
del numbers[0]
print(numbers)  # [1, 2, 3, 4, 5]

del numbers[1:3]
print(numbers)  # [1, 4, 5]

# clear：清空列表
numbers.clear()
print(numbers)  # []

# ========== 查找元素 ==========

fruits = ["apple", "banana", "cherry", "banana"]

# in：检查元素是否存在
print("apple" in fruits)    # True
print("grape" in fruits)    # False

# index：查找元素索引
print(fruits.index("banana"))       # 1（第一个匹配）
# print(fruits.index("grape"))      # ❌ ValueError

# count：统计元素出现次数
print(fruits.count("banana"))       # 2
print(fruits.count("grape"))        # 0

# ========== 列表操作 ==========

numbers = [3, 1, 4, 1, 5, 9, 2, 6]

# 排序
numbers.sort()              # 原地排序
print(numbers)              # [1, 1, 2, 3, 4, 5, 6, 9]

numbers.sort(reverse=True)  # 降序排序
print(numbers)              # [9, 6, 5, 4, 3, 2, 1, 1]

# sorted：返回新列表
original = [3, 1, 4, 1, 5]
sorted_list = sorted(original)
print(original)             # [3, 1, 4, 1, 5]（不变）
print(sorted_list)          # [1, 1, 3, 4, 5]

# 反转
numbers.reverse()
print(numbers)              # [1, 1, 2, 3, 4, 5, 6, 9]

# 长度
print(len(numbers))         # 8

# 最大值、最小值、求和
print(max(numbers))         # 9
print(min(numbers))         # 1
print(sum(numbers))         # 31

# 复制列表
original = [1, 2, 3]
copy1 = original.copy()     # 方法1
copy2 = original[:]         # 方法2
copy3 = list(original)      # 方法3

# ========== 列表遍历 ==========

fruits = ["apple", "banana", "cherry"]

# 方法1：直接遍历
for fruit in fruits:
    print(fruit)

# 方法2：带索引遍历
for i in range(len(fruits)):
    print(f"{i}: {fruits[i]}")

# 方法3：enumerate（推荐）
for index, fruit in enumerate(fruits):
    print(f"{index}: {fruit}")

# 从1开始编号
for index, fruit in enumerate(fruits, start=1):
    print(f"{index}: {fruit}")
```

#### Java数组和ArrayList

```java

import java.util.*;

public class ListExample {
    public static void main(String[] args) {
        // ========== 数组（固定大小）==========
        
        // 创建数组
        int[] numbers = new int[5];         // 创建长度为5的数组
        int[] numbers2 = {1, 2, 3, 4, 5};   // 初始化数组
        String[] fruits = {"apple", "banana", "cherry"};
        
        // 访问元素
        System.out.println(fruits[0]);      // "apple"
        System.out.println(fruits[2]);      // "cherry"
        
        // 修改元素
        fruits[1] = "blueberry";
        
        // 数组长度
        System.out.println(fruits.length);  // 3
        
        // 遍历数组
        for (int i = 0; i < fruits.length; i++) {
            System.out.println(fruits[i]);
        }
        
        // 增强for循环
        for (String fruit : fruits) {
            System.out.println(fruit);
        }
        
        // 数组工具类
        Arrays.sort(numbers2);              // 排序
        System.out.println(Arrays.toString(numbers2));  // 打印数组
        
        // ========== ArrayList（动态大小）==========
        
        // 创建ArrayList
        ArrayList<String> fruitList = new ArrayList<>();
        ArrayList<Integer> numberList = new ArrayList<>(Arrays.asList(1, 2, 3));
        
        // 添加元素
        fruitList.add("apple");             // 末尾添加
        fruitList.add("banana");
        fruitList.add(0, "cherry");         // 指定位置插入
        
        // 添加多个元素
        fruitList.addAll(Arrays.asList("date", "elderberry"));
        
        // 访问元素
        System.out.println(fruitList.get(0));       // "cherry"
        System.out.println(fruitList.get(2));       // "banana"
        
        // 修改元素
        fruitList.set(1, "blueberry");
        
        // 删除元素
        fruitList.remove("banana");         // 删除指定值
        fruitList.remove(0);                // 删除指定索引
        
        // 查找元素
        System.out.println(fruitList.contains("apple"));    // true
        System.out.println(fruitList.indexOf("apple"));     // 索引位置
        
        // 列表大小
        System.out.println(fruitList.size());
        
        // 清空列表
        fruitList.clear();
        
        // 判断是否为空
        System.out.println(fruitList.isEmpty());    // true
        
        // ========== 列表操作 ==========
        
        List<Integer> nums = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6));
        
        // 排序
        Collections.sort(nums);                     // 升序
        System.out.println(nums);
        
        Collections.sort(nums, Collections.reverseOrder());  // 降序
        System.out.println(nums);
        
        // 反转
        Collections.reverse(nums);
        
        // 最大值、最小值
        System.out.println(Collections.max(nums));
        System.out.println(Collections.min(nums));
        
        // 求和（需要Stream API）
        int sum = nums.stream().mapToInt(Integer::intValue).sum();
        System.out.println(sum);
        
        // 复制列表
        List<Integer> copy1 = new ArrayList<>(nums);
        List<Integer> copy2 = new ArrayList<>();
        copy2.addAll(nums);
        
        // ========== 列表遍历 ==========
        
        List<String> fruits2 = Arrays.asList("apple", "banana", "cherry");
        
        // 方法1：传统for循环
        for (int i = 0; i < fruits2.size(); i++) {
            System.out.println(i + ": " + fruits2.get(i));
        }
        
        // 方法2：增强for循环
        for (String fruit : fruits2) {
            System.out.println(fruit);
        }
        
        // 方法3：forEach + Lambda（Java 8+）
        fruits2.forEach(fruit -> System.out.println(fruit));
        
        // 方法4：带索引遍历（Java 8+）
        IntStream.range(0, fruits2.size())
            .forEach(i -> System.out.println(i + ": " + fruits2.get(i)));
    }
}
```

------

### 3.1.2 高级操作

#### Python列表高级技巧

```python

# ========== 列表推导式 ==========

# 基础用法
squares = [x**2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 带条件的推导式
even_squares = [x**2 for x in range(10) if x % 2 == 0]
print(even_squares)  # [0, 4, 16, 36, 64]

# 多重循环
pairs = [(x, y) for x in range(3) for y in range(3)]
print(pairs)  # [(0,0), (0,1), (0,2), (1,0), ...]

# 嵌套列表推导式
matrix = [[i*j for j in range(5)] for i in range(5)]
print(matrix)

# 字符串处理
words = ["hello", "world", "python"]
upper_words = [word.upper() for word in words]
print(upper_words)  # ['HELLO', 'WORLD', 'PYTHON']

# ========== 列表解包 ==========

# 基础解包
a, b, c = [1, 2, 3]
print(a, b, c)  # 1 2 3

# 使用*收集剩余元素
first, *rest = [1, 2, 3, 4, 5]
print(first)    # 1
print(rest)     # [2, 3, 4, 5]

*head, last = [1, 2, 3, 4, 5]
print(head)     # [1, 2, 3, 4]
print(last)     # 5

first, *middle, last = [1, 2, 3, 4, 5]
print(first)    # 1
print(middle)   # [2, 3, 4]
print(last)     # 5

# ========== zip函数 ==========

names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
cities = ["北京", "上海", "深圳"]

# 打包多个列表
for name, age, city in zip(names, ages, cities):
    print(f"{name}, {age}岁, {city}")

# 转换为列表
pairs = list(zip(names, ages))
print(pairs)  # [('Alice', 25), ('Bob', 30), ('Charlie', 35)]

# 解包
names2, ages2 = zip(*pairs)
print(names2)   # ('Alice', 'Bob', 'Charlie')
print(ages2)    # (25, 30, 35)

# ========== map和filter ==========

numbers = [1, 2, 3, 4, 5]

# map：对每个元素应用函数
squared = list(map(lambda x: x**2, numbers))
print(squared)  # [1, 4, 9, 16, 25]

# filter：过滤元素
evens = list(filter(lambda x: x % 2 == 0, numbers))
print(evens)    # [2, 4]

# ========== reduce（需要导入）==========

from functools import reduce

numbers = [1, 2, 3, 4, 5]

# 计算累积和
total = reduce(lambda x, y: x + y, numbers)
print(total)    # 15

# 计算累积积
product = reduce(lambda x, y: x * y, numbers)
print(product)  # 120

# ========== 列表去重 ==========

numbers = [1, 2, 2, 3, 3, 3, 4, 5, 5]

# 方法1：转换为集合
unique = list(set(numbers))
print(unique)   # [1, 2, 3, 4, 5]（顺序可能改变）

# 方法2：保持顺序
unique_ordered = []
for num in numbers:
    if num not in unique_ordered:
        unique_ordered.append(num)
print(unique_ordered)  # [1, 2, 3, 4, 5]

# 方法3：使用dict（Python 3.7+保持顺序）
unique_dict = list(dict.fromkeys(numbers))
print(unique_dict)  # [1, 2, 3, 4, 5]

# ========== 列表扁平化 ==========

nested = [[1, 2], [3, 4], [5, 6]]

# 方法1：列表推导式
flat = [item for sublist in nested for item in sublist]
print(flat)  # [1, 2, 3, 4, 5, 6]

# 方法2：使用sum
flat2 = sum(nested, [])
print(flat2)  # [1, 2, 3, 4, 5, 6]

# 方法3：itertools.chain
from itertools import chain
flat3 = list(chain.from_iterable(nested))
print(flat3)  # [1, 2, 3, 4, 5, 6]

# ========== 列表分组 ==========

def chunk_list(lst, size):
    """将列表分成指定大小的块"""
    return [lst[i:i+size] for i in range(0, len(lst), size)]

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
chunks = chunk_list(numbers, 3)
print(chunks)  # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
```

#### Java列表高级操作

```java
import java.util.*;
import java.util.stream.*;

public class AdvancedListOperations {
    public static void main(String[] args) {
        // ========== Stream API（类似列表推导式）==========
        
        // 生成平方数列表
        List<Integer> squares = IntStream.range(0, 10)
            .map(x -> x * x)
            .boxed()
            .collect(Collectors.toList());
        System.out.println(squares);
        
        // 带条件过滤
        List<Integer> evenSquares = IntStream.range(0, 10)
            .filter(x -> x % 2 == 0)
            .map(x -> x * x)
            .boxed()
            .collect(Collectors.toList());
        System.out.println(evenSquares);
        
        // 字符串处理
        List<String> words = Arrays.asList("hello", "world", "python");
        List<String> upperWords = words.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        System.out.println(upperWords);
        
        // ========== map和filter ==========
        
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
        
        // map：转换每个元素
        List<Integer> squared = numbers.stream()
            .map(x -> x * x)
            .collect(Collectors.toList());
        System.out.println(squared);
        
        // filter：过滤元素
        List<Integer> evens = numbers.stream()
            .filter(x -> x % 2 == 0)
            .collect(Collectors.toList());
        System.out.println(evens);
        
        // ========== reduce ==========
        
        // 计算总和
        int sum = numbers.stream()
            .reduce(0, (a, b) -> a + b);
        System.out.println(sum);  // 15
        
        // 或使用sum()
        int sum2 = numbers.stream()
            .mapToInt(Integer::intValue)
            .sum();
        
        // 计算乘积
        int product = numbers.stream()
            .reduce(1, (a, b) -> a * b);
        System.out.println(product);  // 120
        
        // ========== 列表去重 ==========
        
        List<Integer> nums = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 5, 5);
        
        // 方法1：使用Set
        List<Integer> unique = new ArrayList<>(new HashSet<>(nums));
        System.out.println(unique);
        
        // 方法2：使用Stream（保持顺序）
        List<Integer> uniqueOrdered = nums.stream()
            .distinct()
            .collect(Collectors.toList());
        System.out.println(uniqueOrdered);
        
        // ========== 列表扁平化 ==========
        
        List<List<Integer>> nested = Arrays.asList(
            Arrays.asList(1, 2),
            Arrays.asList(3, 4),
            Arrays.asList(5, 6)
        );
        
        List<Integer> flat = nested.stream()
            .flatMap(List::stream)
            .collect(Collectors.toList());
        System.out.println(flat);  // [1, 2, 3, 4, 5, 6]
        
        // ========== 列表分组 ==========
        
        List<Integer> numbers2 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
        
        // 按条件分组
        Map<Boolean, List<Integer>> partitioned = numbers2.stream()
            .collect(Collectors.partitioningBy(n -> n % 2 == 0));
        System.out.println("偶数: " + partitioned.get(true));
        System.out.println("奇数: " + partitioned.get(false));
        
        // 自定义分组
        public static <T> List<List<T>> chunkList(List<T> list, int size) {
            List<List<T>> chunks = new ArrayList<>();
            for (int i = 0; i < list.size(); i += size) {
                chunks.add(list.subList(i, Math.min(i + size, list.size())));
            }
            return chunks;
        }
        
        // ========== 列表统计 ==========
        
        IntSummaryStatistics stats = numbers.stream()
            .mapToInt(Integer::intValue)
            .summaryStatistics();
        
        System.out.println("数量: " + stats.getCount());
        System.out.println("总和: " + stats.getSum());
        System.out.println("最小值: " + stats.getMin());
        System.out.println("最大值: " + stats.getMax());
        System.out.println("平均值: " + stats.getAverage());
    }
}
```

------

### 3.1.3 性能对比

```python
# Python列表性能测试
import time

def performance_test():
    # 测试append性能
    start = time.time()
    lst = []
    for i in range(1000000):
        lst.append(i)
    print(f"append耗时: {time.time() - start:.4f}秒")
    
    # 测试列表推导式性能
    start = time.time()
    lst2 = [i for i in range(1000000)]
    print(f"列表推导式耗时: {time.time() - start:.4f}秒")
    
    # 测试查找性能
    start = time.time()
    result = 999999 in lst
    print(f"查找耗时: {time.time() - start:.4f}秒")

performance_test()
java复制// Java列表性能测试
import java.util.*;

public class PerformanceTest {
    public static void main(String[] args) {
        // 测试ArrayList添加性能
        long start = System.currentTimeMillis();
        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 0; i < 1000000; i++) {
            list.add(i);
        }
        System.out.println("ArrayList添加耗时: " + 
            (System.currentTimeMillis() - start) + "ms");
        
        // 测试LinkedList添加性能
        start = System.currentTimeMillis();
        LinkedList<Integer> linkedList = new LinkedList<>();
        for (int i = 0; i < 1000000; i++) {
            linkedList.add(i);
        }
        System.out.println("LinkedList添加耗时: " + 
            (System.currentTimeMillis() - start) + "ms");
        
        // 测试查找性能
        start = System.currentTimeMillis();
        boolean result = list.contains(999999);
        System.out.println("ArrayList查找耗时: " + 
            (System.currentTimeMillis() - start) + "ms");
    }
}
```

**性能总结：**

| 操作             | Python List | Java ArrayList | Java LinkedList |
| ---------------- | ----------- | -------------- | --------------- |
| **末尾添加**     | O(1)        | O(1)           | O(1)            |
| **指定位置插入** | O(n)        | O(n)           | O(n)            |
| **访问元素**     | O(1)        | O(1)           | O(n)            |
| **查找元素**     | O(n)        | O(n)           | O(n)            |
| **删除元素**     | O(n)        | O(n)           | O(n)            |

------

## 3.2 字典/Map (35分钟)

### 3.2.1 基础操作

#### Python字典（Dict）

```python
# ========== 创建字典 ==========

# 空字典
empty_dict = {}
empty_dict2 = dict()

# 初始化字典
person = {
    "name": "张三",
    "age": 25,
    "city": "北京"
}

# 使用dict()函数
person2 = dict(name="李四", age=30, city="上海")

# 从键值对列表创建
pairs = [("name", "王五"), ("age", 28)]
person3 = dict(pairs)

# 使用字典推导式
squares = {x: x**2 for x in range(5)}
print(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# ========== 访问元素 ==========

person = {"name": "张三", "age": 25, "city": "北京"}

# 使用键访问
print(person["name"])       # "张三"
# print(person["gender"])   # ❌ KeyError

# 使用get方法（推荐）
print(person.get("name"))   # "张三"
print(person.get("gender")) # None（不会报错）
print(person.get("gender", "未知"))  # "未知"（默认值）

# ========== 修改和添加 ==========

person = {"name": "张三", "age": 25}

# 修改值
person["age"] = 26

# 添加新键值对
person["city"] = "北京"
person["email"] = "zhangsan@example.com"

print(person)
# {'name': '张三', 'age': 26, 'city': '北京', 'email': 'zhangsan@example.com'}

# update方法：批量更新
person.update({"age": 27, "phone": "13800138000"})
print(person)

# ========== 删除元素 ==========

person = {"name": "张三", "age": 25, "city": "北京"}

# del：删除指定键
del person["city"]
print(person)  # {'name': '张三', 'age': 25}

# pop：删除并返回值
age = person.pop("age")
print(age)      # 25
print(person)   # {'name': '张三'}

# pop with default
gender = person.pop("gender", "未知")
print(gender)   # "未知"

# popitem：删除并返回最后一个键值对（Python 3.7+保持插入顺序）
person = {"name": "张三", "age": 25, "city": "北京"}
last_item = person.popitem()
print(last_item)  # ('city', '北京')

# clear：清空字典
person.clear()
print(person)   # {}

# ========== 检查键是否存在 ==========

person = {"name": "张三", "age": 25}

# in 运算符
print("name" in person)     # True
print("gender" in person)   # False

# not in
print("gender" not in person)  # True

# ========== 获取所有键、值、键值对 ==========

person = {"name": "张三", "age": 25, "city": "北京"}

# 获取所有键
keys = person.keys()
print(keys)         # dict_keys(['name', 'age', 'city'])
print(list(keys))   # ['name', 'age', 'city']

# 获取所有值
values = person.values()
print(values)       # dict_values(['张三', 25, '北京'])
print(list(values)) # ['张三', 25, '北京']

# 获取所有键值对
items = person.items()
print(items)        # dict_items([('name', '张三'), ('age', 25), ('city', '北京')])
print(list(items))  # [('name', '张三'), ('age', 25), ('city', '北京')]

# ========== 遍历字典 ==========

person = {"name": "张三", "age": 25, "city": "北京"}

# 遍历键
for key in person:
    print(key)

for key in person.keys():
    print(key)

# 遍历值
# 遍历值
for value in person.values():
    print(value)

# 遍历键值对（推荐）
for key, value in person.items():
    print(f"{key}: {value}")

# ========== 字典复制 ==========

original = {"name": "张三", "age": 25}

# 浅拷贝
copy1 = original.copy()
copy2 = dict(original)
copy3 = {**original}  # Python 3.5+

# 深拷贝（嵌套字典）
import copy
nested = {"person": {"name": "张三", "age": 25}}
deep_copy = copy.deepcopy(nested)

# ========== 字典合并 ==========

dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}

# 方法1：update
dict1.update(dict2)
print(dict1)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}

# 方法2：** 解包（Python 3.5+）
dict1 = {"a": 1, "b": 2}
merged = {**dict1, **dict2}
print(merged)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}

# 方法3：| 运算符（Python 3.9+）
merged2 = dict1 | dict2
print(merged2)

# ========== 默认字典（defaultdict）==========

from collections import defaultdict

# 普通字典的问题
word_count = {}
words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
for word in words:
    if word not in word_count:
        word_count[word] = 0
    word_count[word] += 1

# 使用defaultdict简化
word_count2 = defaultdict(int)  # 默认值为0
for word in words:
    word_count2[word] += 1
print(dict(word_count2))  # {'apple': 3, 'banana': 2, 'cherry': 1}

# 默认值为列表
groups = defaultdict(list)
data = [("fruit", "apple"), ("vegetable", "carrot"), ("fruit", "banana")]
for category, item in data:
    groups[category].append(item)
print(dict(groups))  # {'fruit': ['apple', 'banana'], 'vegetable': ['carrot']}

# ========== 有序字典（OrderedDict）==========

from collections import OrderedDict

# Python 3.7+普通字典已保持插入顺序
# OrderedDict提供额外功能

ordered = OrderedDict()
ordered["first"] = 1
ordered["second"] = 2
ordered["third"] = 3

# 移动到末尾
ordered.move_to_end("first")
print(ordered)  # OrderedDict([('second', 2), ('third', 3), ('first', 1)])

# 移动到开头
ordered.move_to_end("third", last=False)
print(ordered)  # OrderedDict([('third', 3), ('second', 2), ('first', 1)])

# ========== 计数器（Counter）==========

from collections import Counter

# 统计元素出现次数
words = ["apple", "banana", "apple", "cherry", "banana", "apple"]
counter = Counter(words)
print(counter)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})

# 最常见的元素
print(counter.most_common(2))  # [('apple', 3), ('banana', 2)]

# 字符统计
text = "hello world"
char_count = Counter(text)
print(char_count)  # Counter({'l': 3, 'o': 2, 'h': 1, ...})

# Counter运算
c1 = Counter(['a', 'b', 'c', 'a'])
c2 = Counter(['a', 'b', 'd'])
print(c1 + c2)  # Counter({'a': 3, 'b': 2, 'c': 1, 'd': 1})
print(c1 - c2)  # Counter({'a': 1, 'c': 1})

```



#### Java Map

```java
import java.util.*;

public class MapExample {
    public static void main(String[] args) {
        // ========== 创建Map ==========
        
        // HashMap（无序）
        Map<String, Object> person = new HashMap<>();
        
        // 初始化
        Map<String, Object> person2 = new HashMap<>() {{
            put("name", "张三");
            put("age", 25);
            put("city", "北京");
        }};
        
        // Java 9+ Map.of（不可变）
        Map<String, Object> person3 = Map.of(
            "name", "李四",
            "age", 30,
            "city", "上海"
        );
        
        // ========== 访问元素 ==========
        
        person.put("name", "张三");
        person.put("age", 25);
        person.put("city", "北京");
        
        // 使用get
        System.out.println(person.get("name"));     // "张三"
        System.out.println(person.get("gender"));   // null
        
        // getOrDefault
        System.out.println(person.getOrDefault("gender", "未知"));  // "未知"
        
        // ========== 修改和添加 ==========
        
        // 修改值
        person.put("age", 26);
        
        // 添加新键值对
        person.put("email", "zhangsan@example.com");
        
        // putAll：批量添加
        Map<String, Object> additional = new HashMap<>();
        additional.put("phone", "13800138000");
        additional.put("address", "朝阳区");
        person.putAll(additional);
        
        // putIfAbsent：键不存在时才添加
        person.putIfAbsent("name", "李四");  // 不会修改
        person.putIfAbsent("gender", "男");  // 会添加
        
        // ========== 删除元素 ==========
        
        // remove：删除指定键
        person.remove("city");
        
        // remove：删除指定键值对
        person.remove("age", 25);  // 只有值匹配时才删除
        
        // clear：清空
        person.clear();
        
        // ========== 检查键是否存在 ==========
        
        person.put("name", "张三");
        person.put("age", 25);
        
        System.out.println(person.containsKey("name"));     // true
        System.out.println(person.containsKey("gender"));   // false
        System.out.println(person.containsValue(25));       // true
        
        // ========== 获取所有键、值、键值对 ==========
        
        // 获取所有键
        Set<String> keys = person.keySet();
        System.out.println(keys);
        
        // 获取所有值
        Collection<Object> values = person.values();
        System.out.println(values);
        
        // 获取所有键值对
        Set<Map.Entry<String, Object>> entries = person.entrySet();
        System.out.println(entries);
        
        // ========== 遍历Map ==========
        
        // 方法1：遍历键
        for (String key : person.keySet()) {
            System.out.println(key + ": " + person.get(key));
        }
        
        // 方法2：遍历键值对（推荐）
        for (Map.Entry<String, Object> entry : person.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 方法3：forEach + Lambda（Java 8+）
        person.forEach((key, value) -> 
            System.out.println(key + ": " + value)
        );
        
        // ========== Map复制 ==========
        
        Map<String, Object> original = new HashMap<>();
        original.put("name", "张三");
        original.put("age", 25);
        
        // 浅拷贝
        Map<String, Object> copy1 = new HashMap<>(original);
        
        // ========== Map合并 ==========
        
        Map<String, Integer> map1 = new HashMap<>();
        map1.put("a", 1);
        map1.put("b", 2);
        
        Map<String, Integer> map2 = new HashMap<>();
        map2.put("c", 3);
        map2.put("d", 4);
        
        // putAll
        map1.putAll(map2);
        System.out.println(map1);
        
        // merge：合并时处理冲突
        Map<String, Integer> m1 = new HashMap<>();
        m1.put("a", 1);
        m1.put("b", 2);
        
        Map<String, Integer> m2 = new HashMap<>();
        m2.put("b", 3);
        m2.put("c", 4);
        
        m2.forEach((key, value) -> 
            m1.merge(key, value, (v1, v2) -> v1 + v2)
        );
        System.out.println(m1);  // {a=1, b=5, c=4}
        
        // ========== LinkedHashMap（保持插入顺序）==========
        
        Map<String, Integer> linkedMap = new LinkedHashMap<>();
        linkedMap.put("third", 3);
        linkedMap.put("first", 1);
        linkedMap.put("second", 2);
        System.out.println(linkedMap);  // {third=3, first=1, second=2}
        
        // ========== TreeMap（排序）==========
        
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("c", 3);
        treeMap.put("a", 1);
        treeMap.put("b", 2);
        System.out.println(treeMap);  // {a=1, b=2, c=3}（按键排序）
        
        // ========== 计数Map ==========
        
        String[] words = {"apple", "banana", "apple", "cherry", "banana", "apple"};
        Map<String, Integer> wordCount = new HashMap<>();
        
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }
        System.out.println(wordCount);  // {apple=3, banana=2, cherry=1}
        
        // 或使用merge
        Map<String, Integer> wordCount2 = new HashMap<>();
        for (String word : words) {
            wordCount2.merge(word, 1, Integer::sum);
        }
        System.out.println(wordCount2);
        
        // ========== 分组Map ==========
        
        List<String> items = Arrays.asList("apple", "apricot", "banana", "blueberry", "cherry");
        
        // 按首字母分组
        Map<Character, List<String>> grouped = new HashMap<>();
        for (String item : items) {
            char firstChar = item.charAt(0);
            grouped.computeIfAbsent(firstChar, k -> new ArrayList<>()).add(item);
        }
        System.out.println(grouped);
        // {a=[apple, apricot], b=[banana, blueberry], c=[cherry]}
        
        // 使用Stream API
        Map<Character, List<String>> grouped2 = items.stream()
            .collect(Collectors.groupingBy(s -> s.charAt(0)));
        System.out.println(grouped2);
    }
}
```

------

### 3.2.2 高级操作

#### Python字典高级技巧

```python
# ========== 字典推导式 ==========

# 基础用法
squares = {x: x**2 for x in range(5)}
print(squares)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 带条件
even_squares = {x: x**2 for x in range(10) if x % 2 == 0}
print(even_squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

# 交换键值
original = {"a": 1, "b": 2, "c": 3}
swapped = {v: k for k, v in original.items()}
print(swapped)  # {1: 'a', 2: 'b', 3: 'c'}

# 过滤字典
person = {"name": "张三", "age": 25, "city": "北京", "email": ""}
filtered = {k: v for k, v in person.items() if v}
print(filtered)  # {'name': '张三', 'age': 25, 'city': '北京'}

# ========== 嵌套字典 ==========

# 创建嵌套字典
students = {
    "student1": {
        "name": "张三",
        "age": 20,
        "scores": {"math": 90, "english": 85}
    },
    "student2": {
        "name": "李四",
        "age": 21,
        "scores": {"math": 88, "english": 92}
    }
}

# 访问嵌套值
print(students["student1"]["name"])  # "张三"
print(students["student1"]["scores"]["math"])  # 90

# 安全访问（使用get）
math_score = students.get("student1", {}).get("scores", {}).get("math")
print(math_score)  # 90

# ========== 字典排序 ==========

scores = {"Alice": 85, "Bob": 92, "Charlie": 78, "David": 95}

# 按键排序
sorted_by_key = dict(sorted(scores.items()))
print(sorted_by_key)  # {'Alice': 85, 'Bob': 92, 'Charlie': 78, 'David': 95}

# 按值排序
sorted_by_value = dict(sorted(scores.items(), key=lambda x: x[1]))
print(sorted_by_value)  # {'Charlie': 78, 'Alice': 85, 'Bob': 92, 'David': 95}

# 按值降序
sorted_desc = dict(sorted(scores.items(), key=lambda x: x[1], reverse=True))
print(sorted_desc)  # {'David': 95, 'Bob': 92, 'Alice': 85, 'Charlie': 78}

# ========== 字典转换 ==========

# 列表转字典
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
person_dict = dict(zip(names, ages))
print(person_dict)  # {'Alice': 25, 'Bob': 30, 'Charlie': 35}

# 字典转列表
items = list(person_dict.items())
print(items)  # [('Alice', 25), ('Bob', 30), ('Charlie', 35)]

keys = list(person_dict.keys())
values = list(person_dict.values())

# ========== 字典合并高级技巧 ==========

dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}

# 保留dict2的值
merged = {**dict1, **dict2}
print(merged)  # {'a': 1, 'b': 3, 'c': 4}

# 自定义合并逻辑
def merge_dicts(d1, d2, merge_func):
    result = d1.copy()
    for key, value in d2.items():
        if key in result:
            result[key] = merge_func(result[key], value)
        else:
            result[key] = value
    return result

# 值相加
merged_sum = merge_dicts(dict1, dict2, lambda x, y: x + y)
print(merged_sum)  # {'a': 1, 'b': 5, 'c': 4}

# ========== 字典反转（多值）==========

# 一对多关系反转
students_by_class = {
    "Class1": ["Alice", "Bob"],
    "Class2": ["Charlie", "David"],
    "Class3": ["Alice", "Eve"]
}

# 反转为学生到班级的映射
class_by_student = {}
for class_name, students in students_by_class.items():
    for student in students:
        if student not in class_by_student:
            class_by_student[student] = []
        class_by_student[student].append(class_name)

print(class_by_student)
# {'Alice': ['Class1', 'Class3'], 'Bob': ['Class1'], ...}

# 使用defaultdict简化
from collections import defaultdict
class_by_student2 = defaultdict(list)
for class_name, students in students_by_class.items():
    for student in students:
        class_by_student2[student].append(class_name)
```

#### Java Map高级操作

```java
import java.util.*;
import java.util.stream.*;

public class AdvancedMapOperations {
    public static void main(String[] args) {
        // ========== 嵌套Map ==========
        
        Map<String, Map<String, Object>> students = new HashMap<>();
        
        Map<String, Object> student1 = new HashMap<>();
        student1.put("name", "张三");
        student1.put("age", 20);
        Map<String, Integer> scores1 = new HashMap<>();
        scores1.put("math", 90);
        scores1.put("english", 85);
        student1.put("scores", scores1);
        
        students.put("student1", student1);
        
        // 访问嵌套值
        String name = (String) students.get("student1").get("name");
        System.out.println(name);  // "张三"
        
        // ========== Map排序 ==========
        
        Map<String, Integer> scores = new HashMap<>();
        scores.put("Alice", 85);
        scores.put("Bob", 92);
        scores.put("Charlie", 78);
        scores.put("David", 95);
        
        // 按键排序
        Map<String, Integer> sortedByKey = new TreeMap<>(scores);
        System.out.println(sortedByKey);
        
        // 按值排序
        List<Map.Entry<String, Integer>> entries = new ArrayList<>(scores.entrySet());
        entries.sort(Map.Entry.comparingByValue());
        
        Map<String, Integer> sortedByValue = new LinkedHashMap<>();
        for (Map.Entry<String, Integer> entry : entries) {
            sortedByValue.put(entry.getKey(), entry.getValue());
        }
        System.out.println(sortedByValue);
        
        // 使用Stream API排序
        Map<String, Integer> sortedByValueStream = scores.entrySet().stream()
            .sorted(Map.Entry.comparingByValue())
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                Map.Entry::getValue,
                (e1, e2) -> e1,
                LinkedHashMap::new
            ));
        System.out.println(sortedByValueStream);
        
        // 按值降序
        Map<String, Integer> sortedDesc = scores.entrySet().stream()
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                Map.Entry::getValue,
                (e1, e2) -> e1,
                LinkedHashMap::new
            ));
        System.out.println(sortedDesc);
        
        // ========== Map转换 ==========
        
        // 列表转Map
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        List<Integer> ages = Arrays.asList(25, 30, 35);
        
        Map<String, Integer> personMap = IntStream.range(0, names.size())
            .boxed()
            .collect(Collectors.toMap(names::get, ages::get));
        System.out.println(personMap);
        
        // Map转列表
        List<Map.Entry<String, Integer>> entryList = 
            new ArrayList<>(personMap.entrySet());
        
        List<String> keyList = new ArrayList<>(personMap.keySet());
        List<Integer> valueList = new ArrayList<>(personMap.values());
        
        // ========== 分组和统计 ==========
        
        List<String> words = Arrays.asList(
            "apple", "banana", "apricot", "blueberry", "cherry", "avocado"
        );
        
        // 按长度分组
        Map<Integer, List<String>> byLength = words.stream()
            .collect(Collectors.groupingBy(String::length));
        System.out.println(byLength);
        // {5=[apple], 6=[banana, cherry], 7=[apricot, avocado], 9=[blueberry]}
        
        // 按首字母分组
        Map<Character, List<String>> byFirstChar = words.stream()
            .collect(Collectors.groupingBy(s -> s.charAt(0)));
        System.out.println(byFirstChar);
        
        // 统计每组数量
        Map<Character, Long> countByFirstChar = words.stream()
            .collect(Collectors.groupingBy(
                s -> s.charAt(0),
                Collectors.counting()
            ));
        System.out.println(countByFirstChar);  // {a=3, b=2, c=1}
        
        // ========== Map过滤 ==========
        
        Map<String, Integer> allScores = new HashMap<>();
        allScores.put("Alice", 85);
        allScores.put("Bob", 92);
        allScores.put("Charlie", 78);
        allScores.put("David", 95);
        
        // 过滤分数>=90的学生
        Map<String, Integer> highScores = allScores.entrySet().stream()
            .filter(entry -> entry.getValue() >= 90)
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                Map.Entry::getValue
            ));
        System.out.println(highScores);  // {Bob=92, David=95}
        
        // ========== Map转换值 ==========
        
        Map<String, Integer> prices = new HashMap<>();
        prices.put("apple", 5);
        prices.put("banana", 3);
        prices.put("cherry", 8);
        
        // 所有价格打8折
        Map<String, Double> discountedPrices = prices.entrySet().stream()
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                entry -> entry.getValue() * 0.8
            ));
        System.out.println(discountedPrices);
    }
}
```

------

## 3.3 集合/Set (25分钟)

### 3.3.1 基础操作

#### Python集合（Set）

```python
# ========== 创建集合 ==========

# 空集合（注意：{}创建的是字典）
empty_set = set()

# 初始化集合
numbers = {1, 2, 3, 4, 5}
fruits = {"apple", "banana", "cherry"}

# 从列表创建
list_data = [1, 2, 2, 3, 3, 3, 4]
unique_set = set(list_data)
print(unique_set)  # {1, 2, 3, 4}

# 集合推导式
squares = {x**2 for x in range(5)}
print(squares)  # {0, 1, 4, 9, 16}

# ========== 添加元素 ==========

fruits = {"apple", "banana"}

# add：添加单个元素
fruits.add("cherry")
fruits.add("apple")  # 重复元素不会添加
print(fruits)  # {'apple', 'banana', 'cherry'}

# update：添加多个元素
fruits.update(["date", "elderberry"])
fruits.update({"fig", "grape"})
print(fruits)

# ========== 删除元素 ==========

fruits = {"apple", "banana", "cherry", "date"}

# remove：删除指定元素（不存在会报错）
fruits.remove("banana")
# fruits.remove("grape")  # ❌ KeyError

# discard：删除指定元素（不存在不报错）
fruits.discard("cherry")
fruits.discard("grape")  # 不会报错

# pop：随机删除并返回一个元素
item = fruits.pop()
print(item)

# clear：清空集合
fruits.clear()
print(fruits)  # set()

# ========== 集合运算 ==========

set1 = {1, 2, 3, 4, 5}
set2 = {4, 5, 6, 7, 8}

# 并集（union）
union = set1 | set2
union2 = set1.union(set2)
print(union)  # {1, 2, 3, 4, 5, 6, 7, 8}

# 交集（intersection）
intersection = set1 & set2
intersection2 = set1.intersection(set2)
print(intersection)  # {4, 5}

# 差集（difference）
diff = set1 - set2
diff2 = set1.difference(set2)
print(diff)  # {1, 2, 3}

# 对称差集（symmetric_difference）
sym_diff = set1 ^ set2
sym_diff2 = set1.symmetric_difference(set2)
print(sym_diff)  # {1, 2, 3, 6, 7, 8}

# ========== 集合关系 ==========

set_a = {1, 2, 3}
set_b = {1, 2, 3, 4, 5}
set_c = {6, 7, 8}

# 子集
print(set_a.issubset(set_b))  # True
print(set_a <= set_b)          # True

# 超集
print(set_b.issuperset(set_a))  # True
print(set_b >= set_a)            # True

# 不相交
print(set_a.isdisjoint(set_c))  # True

# ========== 集合操作 ==========

numbers = {3, 1, 4, 1, 5, 9, 2, 6}

# 长度
print(len(numbers))  # 7（去重后）

# 检查元素
print(3 in numbers)  # True
print(10 in numbers)  # False

# 遍历集合
for num in numbers:
    print(num)

# 转换为列表（排序）
sorted_list = sorted(numbers)
print(sorted_list)  # [1, 2, 3, 4, 5, 6, 9]

# ========== 冻结集合（frozenset）==========

# 不可变集合，可以作为字典的键
frozen = frozenset([1, 2, 3])
# frozen.add(4)  # ❌ AttributeError

# 可以作为字典键
dict_with_set_key = {frozen: "value"}
print(dict_with_set_key)

# ========== 实际应用 ==========

# 去重
numbers = [1, 2, 2, 3, 3, 3, 4, 5, 5]
unique = list(set(numbers))
print(unique)

# 查找共同好友
alice_friends = {"Bob", "Charlie", "David"}
bob_friends = {"Alice", "Charlie", "Eve"}
common_friends = alice_friends & bob_friends
print(common_friends)  # {'Charlie'}

# 查找独有好友
alice_only = alice_friends - bob_friends
print(alice_only)  # {'Bob', 'David'}

# 查找所有好友
all_friends = alice_friends | bob_friends
print(all_friends)  # {'Alice', 'Bob', 'Charlie', 'David', 'Eve'}
```

#### Java Set

```java
import java.util.*;

public class SetExample {
    public static void main(String[] args) {
        // ========== 创建Set ==========
        
        // HashSet（无序）
        Set<Integer> numbers = new HashSet<>();
        
        // 初始化
        Set<String> fruits = new HashSet<>(Arrays.asList("apple", "banana", "cherry"));
        
        // Java 9+ Set.of（不可变）
        Set<String> fruits2 = Set.of("apple", "banana", "cherry");
        
        // 从列表创建（去重）
        List<Integer> listData = Arrays.asList(1, 2, 2, 3, 3, 3, 4);
        Set<Integer> uniqueSet = new HashSet<>(listData);
        System.out.println(uniqueSet);  // [1, 2, 3, 4]
        
        // ========== 添加元素 ==========
        
        Set<String> fruitSet = new HashSet<>();
        
        // add：添加单个元素
        fruitSet.add("apple");
        fruitSet.add("banana");
        fruitSet.add("apple");  // 重复元素不会添加
        System.out.println(fruitSet);  // [apple, banana]
        
        // addAll：添加多个元素
        fruitSet.addAll(Arrays.asList("cherry", "date"));
        System.out.println(fruitSet);
        
        // ========== 删除元素 ==========        
        Set<String> fruits3 = new HashSet<>(Arrays.asList("apple", "banana", "cherry", "date"));
        
        // remove：删除指定元素
        fruits3.remove("banana");
        System.out.println(fruits3);
        
        // removeAll：删除多个元素
        fruits3.removeAll(Arrays.asList("cherry", "date"));
        System.out.println(fruits3);
        
        // clear：清空集合
        fruits3.clear();
        System.out.println(fruits3);  // []
        
        // ========== 集合运算 ==========
        
        Set<Integer> set1 = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        Set<Integer> set2 = new HashSet<>(Arrays.asList(4, 5, 6, 7, 8));
        
        // 并集（union）
        Set<Integer> union = new HashSet<>(set1);
        union.addAll(set2);
        System.out.println("并集: " + union);  // [1, 2, 3, 4, 5, 6, 7, 8]
        
        // 交集（intersection）
        Set<Integer> intersection = new HashSet<>(set1);
        intersection.retainAll(set2);
        System.out.println("交集: " + intersection);  // [4, 5]
        
        // 差集（difference）
        Set<Integer> difference = new HashSet<>(set1);
        difference.removeAll(set2);
        System.out.println("差集: " + difference);  // [1, 2, 3]
        
        // 对称差集（symmetric difference）
        Set<Integer> symDiff = new HashSet<>(set1);
        symDiff.addAll(set2);
        Set<Integer> temp = new HashSet<>(set1);
        temp.retainAll(set2);
        symDiff.removeAll(temp);
        System.out.println("对称差集: " + symDiff);  // [1, 2, 3, 6, 7, 8]
        
        // ========== 集合关系 ==========
        
        Set<Integer> setA = new HashSet<>(Arrays.asList(1, 2, 3));
        Set<Integer> setB = new HashSet<>(Arrays.asList(1, 2, 3, 4, 5));
        Set<Integer> setC = new HashSet<>(Arrays.asList(6, 7, 8));
        
        // 子集
        System.out.println("A是B的子集: " + setB.containsAll(setA));  // true
        
        // 超集
        System.out.println("B是A的超集: " + setB.containsAll(setA));  // true
        
        // 不相交
        Set<Integer> tempIntersection = new HashSet<>(setA);
        tempIntersection.retainAll(setC);
        System.out.println("A和C不相交: " + tempIntersection.isEmpty());  // true
        
        // ========== 集合操作 ==========
        
        Set<Integer> numSet = new HashSet<>(Arrays.asList(3, 1, 4, 1, 5, 9, 2, 6));
        
        // 大小
        System.out.println("大小: " + numSet.size());  // 7
        
        // 检查元素
        System.out.println("包含3: " + numSet.contains(3));  // true
        System.out.println("包含10: " + numSet.contains(10));  // false
        
        // 判断是否为空
        System.out.println("是否为空: " + numSet.isEmpty());  // false
        
        // 遍历集合
        for (Integer num : numSet) {
            System.out.println(num);
        }
        
        // forEach + Lambda
        numSet.forEach(num -> System.out.println(num));
        
        // 转换为列表（排序）
        List<Integer> sortedList = new ArrayList<>(numSet);
        Collections.sort(sortedList);
        System.out.println(sortedList);  // [1, 2, 3, 4, 5, 6, 9]
        
        // ========== LinkedHashSet（保持插入顺序）==========
        
        Set<String> linkedSet = new LinkedHashSet<>();
        linkedSet.add("third");
        linkedSet.add("first");
        linkedSet.add("second");
        System.out.println(linkedSet);  // [third, first, second]
        
        // ========== TreeSet（排序）==========
        
        Set<Integer> treeSet = new TreeSet<>(Arrays.asList(5, 2, 8, 1, 9, 3));
        System.out.println(treeSet);  // [1, 2, 3, 5, 8, 9]
        
        // TreeSet的范围操作
        TreeSet<Integer> tree = new TreeSet<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9));
        System.out.println("小于5的元素: " + tree.headSet(5));  // [1, 2, 3, 4]
        System.out.println("大于等于5的元素: " + tree.tailSet(5));  // [5, 6, 7, 8, 9]
        System.out.println("3到7之间: " + tree.subSet(3, 7));  // [3, 4, 5, 6]
        
        // ========== 实际应用 ==========
        
        // 去重
        List<Integer> numberList = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 5, 5);
        List<Integer> unique = new ArrayList<>(new HashSet<>(numberList));
        System.out.println(unique);
        
        // 查找共同好友
        Set<String> aliceFriends = new HashSet<>(Arrays.asList("Bob", "Charlie", "David"));
        Set<String> bobFriends = new HashSet<>(Arrays.asList("Alice", "Charlie", "Eve"));
        
        Set<String> commonFriends = new HashSet<>(aliceFriends);
        commonFriends.retainAll(bobFriends);
        System.out.println("共同好友: " + commonFriends);  // [Charlie]
        
        // 查找独有好友
        Set<String> aliceOnly = new HashSet<>(aliceFriends);
        aliceOnly.removeAll(bobFriends);
        System.out.println("Alice独有好友: " + aliceOnly);  // [Bob, David]
        
        // 查找所有好友
        Set<String> allFriends = new HashSet<>(aliceFriends);
        allFriends.addAll(bobFriends);
        System.out.println("所有好友: " + allFriends);  // [Alice, Bob, Charlie, David, Eve]
    }
}

```

## 3.4 数据结构性能对比 (20分钟)

### 3.4.1 时间复杂度对比表

#### Python数据结构性能

| 操作             | List       | Dict | Set  |
| ---------------- | ---------- | ---- | ---- |
| **访问元素**     | O(1)       | O(1) | -    |
| **查找元素**     | O(n)       | O(1) | O(1) |
| **插入（末尾）** | O(1)       | O(1) | O(1) |
| **插入（开头）** | O(n)       | O(1) | O(1) |
| **插入（中间）** | O(n)       | O(1) | O(1) |
| **删除元素**     | O(n)       | O(1) | O(1) |
| **遍历**         | O(n)       | O(n) | O(n) |
| **排序**         | O(n log n) | -    | -    |

#### Java数据结构性能

| 操作             | ArrayList | LinkedList | HashMap | HashSet | TreeMap  | TreeSet  |
| ---------------- | --------- | ---------- | ------- | ------- | -------- | -------- |
| **访问元素**     | O(1)      | O(n)       | O(1)    | -       | O(log n) | -        |
| **查找元素**     | O(n)      | O(n)       | O(1)    | O(1)    | O(log n) | O(log n) |
| **插入（末尾）** | O(1)      | O(1)       | O(1)    | O(1)    | O(log n) | O(log n) |
| **插入（开头）** | O(n)      | O(1)       | O(1)    | O(1)    | O(log n) | O(log n) |
| **插入（中间）** | O(n)      | O(n)       | O(1)    | O(1)    | O(log n) | O(log n) |
| **删除元素**     | O(n)      | O(n)       | O(1)    | O(1)    | O(log n) | O(log n) |
| **遍历**         | O(n)      | O(n)       | O(n)    | O(n)    | O(n)     | O(n)     |

------

### 3.4.2 选择合适的数据结构

```python
# Python数据结构选择指南

# ========== 场景1：需要有序且可重复的元素 ==========
# 使用：List
shopping_list = ["apple", "banana", "apple", "cherry"]

# ========== 场景2：需要快速查找键值对 ==========
# 使用：Dict
user_info = {
    "id": 1001,
    "name": "张三",
    "email": "zhangsan@example.com"
}

# ========== 场景3：需要唯一元素且不关心顺序 ==========
# 使用：Set
unique_tags = {"python", "java", "javascript"}

# ========== 场景4：需要保持插入顺序的字典 ==========
# 使用：Dict（Python 3.7+）或 OrderedDict
from collections import OrderedDict
ordered_dict = OrderedDict([("first", 1), ("second", 2)])

# ========== 场景5：需要统计元素出现次数 ==========
# 使用：Counter
from collections import Counter
word_count = Counter(["apple", "banana", "apple", "cherry", "banana", "apple"])
print(word_count)  # Counter({'apple': 3, 'banana': 2, 'cherry': 1})

# ========== 场景6：需要默认值的字典 ==========
# 使用：defaultdict
from collections import defaultdict
groups = defaultdict(list)
groups["fruits"].append("apple")

# ========== 场景7：需要双端队列（高效的头尾操作）==========
# 使用：deque
from collections import deque
queue = deque([1, 2, 3])
queue.append(4)      # 尾部添加
queue.appendleft(0)  # 头部添加
queue.pop()          # 尾部删除
queue.popleft()      # 头部删除

# ========== 场景8：需要堆/优先队列 ==========
# 使用：heapq
import heapq
heap = [3, 1, 4, 1, 5, 9, 2, 6]
heapq.heapify(heap)
print(heapq.heappop(heap))  # 1（最小值）
heapq.heappush(heap, 0)
java复制// Java数据结构选择指南

import java.util.*;

public class DataStructureSelection {
    public static void main(String[] args) {
        // ========== 场景1：需要有序且可重复的元素 ==========
        // 使用：ArrayList（随机访问快）或 LinkedList（插入删除快）
        List<String> shoppingList = new ArrayList<>(
            Arrays.asList("apple", "banana", "apple", "cherry")
        );
        
        // ========== 场景2：需要快速查找键值对 ==========
        // 使用：HashMap（无序）或 LinkedHashMap（保持插入顺序）
        Map<String, Object> userInfo = new HashMap<>();
        userInfo.put("id", 1001);
        userInfo.put("name", "张三");
        userInfo.put("email", "zhangsan@example.com");
        
        // ========== 场景3：需要唯一元素且不关心顺序 ==========
        // 使用：HashSet
        Set<String> uniqueTags = new HashSet<>(
            Arrays.asList("python", "java", "javascript")
        );
        
        // ========== 场景4：需要保持插入顺序 ==========
        // 使用：LinkedHashMap 或 LinkedHashSet
        Map<String, Integer> orderedMap = new LinkedHashMap<>();
        orderedMap.put("first", 1);
        orderedMap.put("second", 2);
        
        // ========== 场景5：需要排序的集合 ==========
        // 使用：TreeMap 或 TreeSet
        Set<Integer> sortedSet = new TreeSet<>(Arrays.asList(5, 2, 8, 1, 9));
        System.out.println(sortedSet);  // [1, 2, 5, 8, 9]
        
        // ========== 场景6：需要双端队列 ==========
        // 使用：ArrayDeque
        Deque<Integer> deque = new ArrayDeque<>();
        deque.addLast(1);    // 尾部添加
        deque.addFirst(0);   // 头部添加
        deque.removeLast();  // 尾部删除
        deque.removeFirst(); // 头部删除
        
        // ========== 场景7：需要优先队列 ==========
        // 使用：PriorityQueue
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.offer(3);
        pq.offer(1);
        pq.offer(4);
        System.out.println(pq.poll());  // 1（最小值）
        
        // ========== 场景8：需要栈 ==========
        // 使用：Stack 或 Deque
        Stack<Integer> stack = new Stack<>();
        stack.push(1);
        stack.push(2);
        System.out.println(stack.pop());  // 2
        
        // 或使用Deque（推荐）
        Deque<Integer> stackDeque = new ArrayDeque<>();
        stackDeque.push(1);
        stackDeque.push(2);
        System.out.println(stackDeque.pop());  // 2
        
        // ========== 场景9：需要线程安全的集合 ==========
        // 使用：ConcurrentHashMap, CopyOnWriteArrayList等
        Map<String, Integer> concurrentMap = new java.util.concurrent.ConcurrentHashMap<>();
        
        // ========== 场景10：需要同步的集合 ==========
        // 使用：Collections.synchronized*
        List<String> syncList = Collections.synchronizedList(new ArrayList<>());
        Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
    }
}
```

------

## 3.5 实战项目：通讯录管理系统 (35分钟)

### 3.5.1 需求分析

**功能需求：**

1. 添加联系人（姓名、电话、邮箱、地址）
2. 删除联系人
3. 修改联系人信息
4. 查询联系人（按姓名、电话）
5. 显示所有联系人
6. 按姓名排序显示
7. 数据持久化（保存到文件）

------

### 3.5.2 Python实现

```python
import json
import os

class Contact:
    """联系人类"""
    def __init__(self, name, phone, email="", address=""):
        self.name = name
        self.phone = phone
        self.email = email
        self.address = address
    
    def to_dict(self):
        """转换为字典"""
        return {
            "name": self.name,
            "phone": self.phone,
            "email": self.email,
            "address": self.address
        }
    
    @staticmethod
    def from_dict(data):
        """从字典创建联系人"""
        return Contact(
            data["name"],
            data["phone"],
            data.get("email", ""),
            data.get("address", "")
        )
    
    def __str__(self):
        """字符串表示"""
        return f"姓名: {self.name}\n电话: {self.phone}\n邮箱: {self.email}\n地址: {self.address}"


class ContactBook:
    """通讯录类"""
    def __init__(self, filename="contacts.json"):
        self.filename = filename
        self.contacts = {}  # 使用字典存储，键为电话号码
        self.load_contacts()
    
    def add_contact(self, contact):
        """添加联系人"""
        if contact.phone in self.contacts:
            print(f"错误：电话号码 {contact.phone} 已存在！")
            return False
        
        self.contacts[contact.phone] = contact
        print(f"成功添加联系人：{contact.name}")
        self.save_contacts()
        return True
    
    def delete_contact(self, phone):
        """删除联系人"""
        if phone in self.contacts:
            name = self.contacts[phone].name
            del self.contacts[phone]
            print(f"成功删除联系人：{name}")
            self.save_contacts()
            return True
        else:
            print(f"错误：未找到电话号码 {phone}")
            return False
    
    def update_contact(self, phone, **kwargs):
        """更新联系人信息"""
        if phone not in self.contacts:
            print(f"错误：未找到电话号码 {phone}")
            return False
        
        contact = self.contacts[phone]
        if "name" in kwargs:
            contact.name = kwargs["name"]
        if "email" in kwargs:
            contact.email = kwargs["email"]
        if "address" in kwargs:
            contact.address = kwargs["address"]
        
        print(f"成功更新联系人：{contact.name}")
        self.save_contacts()
        return True
    
    def search_by_name(self, name):
        """按姓名搜索"""
        results = [c for c in self.contacts.values() if name.lower() in c.name.lower()]
        return results
    
    def search_by_phone(self, phone):
        """按电话搜索"""
        return self.contacts.get(phone)
    
    def get_all_contacts(self):
        """获取所有联系人"""
        return list(self.contacts.values())
    
    def get_sorted_contacts(self):
        """按姓名排序获取联系人"""
        return sorted(self.contacts.values(), key=lambda c: c.name)
    
    def save_contacts(self):
        """保存到文件"""
        data = {phone: contact.to_dict() for phone, contact in self.contacts.items()}
        with open(self.filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
    
    def load_contacts(self):
        """从文件加载"""
        if os.path.exists(self.filename):
            try:
                with open(self.filename, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    self.contacts = {
                        phone: Contact.from_dict(contact_data)
                        for phone, contact_data in data.items()
                    }
                print(f"成功加载 {len(self.contacts)} 个联系人")
            except Exception as e:
                print(f"加载文件失败：{e}")
                self.contacts = {}
        else:
            self.contacts = {}
    
    def display_all(self):
        """显示所有联系人"""
        if not self.contacts:
            print("通讯录为空")
            return
        
        print(f"\n{'='*50}")
        print(f"共有 {len(self.contacts)} 个联系人")
        print(f"{'='*50}")
        for contact in self.get_sorted_contacts():
            print(contact)
            print("-" * 50)


def main():
    """主函数"""
    book = ContactBook()
    
    while True:
        print("\n" + "="*50)
        print("通讯录管理系统")
        print("="*50)
        print("1. 添加联系人")
        print("2. 删除联系人")
        print("3. 修改联系人")
        print("4. 查询联系人")
        print("5. 显示所有联系人")
        print("6. 退出")
        print("="*50)
        
        choice = input("请选择操作 (1-6): ").strip()
        
        if choice == "1":
            # 添加联系人
            print("\n--- 添加联系人 ---")
            name = input("姓名: ").strip()
            phone = input("电话: ").strip()
            email = input("邮箱（可选）: ").strip()
            address = input("地址（可选）: ").strip()
            
            if name and phone:
                contact = Contact(name, phone, email, address)
                book.add_contact(contact)
            else:
                print("错误：姓名和电话不能为空！")
        
        elif choice == "2":
            # 删除联系人
            print("\n--- 删除联系人 ---")
            phone = input("请输入要删除的电话号码: ").strip()
            book.delete_contact(phone)
        
        elif choice == "3":
            # 修改联系人
            print("\n--- 修改联系人 ---")
            phone = input("请输入要修改的电话号码: ").strip()
            contact = book.search_by_phone(phone)
            
            if contact:
                print(f"\n当前信息：\n{contact}\n")
                name = input(f"新姓名（当前：{contact.name}，回车跳过）: ").strip()
                email = input(f"新邮箱（当前：{contact.email}，回车跳过）: ").strip()
                address = input(f"新地址（当前：{contact.address}，回车跳过）: ").strip()
                
                updates = {}
                if name:
                    updates["name"] = name
                if email:
                    updates["email"] = email
                if address:
                    updates["address"] = address
                
                if updates:
                    book.update_contact(phone, **updates)
                else:
                    print("未进行任何修改")
        
        elif choice == "4":
            # 查询联系人
            print("\n--- 查询联系人 ---")
            print("1. 按姓名查询")
            print("2. 按电话查询")
            sub_choice = input("请选择查询方式 (1-2): ").strip()
            
            if sub_choice == "1":
                name = input("请输入姓名（支持模糊查询）: ").strip()
                results = book.search_by_name(name)
                if results:
                    print(f"\n找到 {len(results)} 个匹配结果：")
                    for contact in results:
                        print("-" * 50)
                        print(contact)
                else:
                    print("未找到匹配的联系人")
            
            elif sub_choice == "2":
                phone = input("请输入电话号码: ").strip()
                contact = book.search_by_phone(phone)
                if contact:
                    print("\n" + "-" * 50)
                    print(contact)
                else:
                    print("未找到该联系人")
        
        elif choice == "5":
            # 显示所有联系人
            book.display_all()
        
        elif choice == "6":
            # 退出
            print("感谢使用，再见！")
            break
        
        else:
            print("无效的选择，请重新输入！")


if __name__ == "__main__":
    main()
```

------

### 3.5.3 Java实现

```java

import java.io.*;
import java.util.*;
import com.google.gson.*;

// 联系人类
class Contact implements Serializable {
    private String name;
    private String phone;
    private String email;
    private String address;
    
    public Contact(String name, String phone, String email, String address) {
        this.name = name;
        this.phone = phone;
        this.email = email != null ? email : "";
        this.address = address != null ? address : "";
    }
    
    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getPhone() { return phone; }
    public void setPhone(String phone) { this.phone = phone; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    
    public String getAddress() { return address; }
    public void setAddress(String address) { this.address = address; }
    
    @Override
    public String toString() {
        return String.format("姓名: %s\n电话: %s\n邮箱: %s\n地址: %s",
            name, phone, email, address);
    }
}

// 通讯录类
class ContactBook {
    private Map<String, Contact> contacts;  // 键为电话号码
    private String filename;
    private Gson gson;
    
    public ContactBook(String filename) {
        this.filename = filename;
        this.contacts = new HashMap<>();
        this.gson = new GsonBuilder().setPrettyPrinting().create();
        loadContacts();
    }
    
    // 添加联系人
    public boolean addContact(Contact contact) {
        if (contacts.containsKey(contact.getPhone())) {
            System.out.println("错误：电话号码 " + contact.getPhone() + " 已存在！");
            return false;
        }
        
        contacts.put(contact.getPhone(), contact);
        System.out.println("成功添加联系人：" + contact.getName());
        saveContacts();
        return true;
    }
    
    // 删除联系人
    public boolean deleteContact(String phone) {
        Contact contact = contacts.remove(phone);
        if (contact != null) {
            System.out.println("成功删除联系人：" + contact.getName());
            saveContacts();
            return true;
        } else {
            System.out.println("错误：未找到电话号码 " + phone);
            return false;
        }
    }
    
    // 更新联系人
    public boolean updateContact(String phone, String name, String email, String address) {
        Contact contact = contacts.get(phone);
        if (contact == null) {
            System.out.println("错误：未找到电话号码 " + phone);
            return false;
        }
        
        if (name != null && !name.isEmpty()) {
            contact.setName(name);
        }
        if (email != null && !email.isEmpty()) {
            contact.setEmail(email);
        }
        if (address != null && !address.isEmpty()) {
            contact.setAddress(address);
        }
        
        System.out.println("成功更新联系人：" + contact.getName());
        saveContacts();
        return true;
    }
    
    // 按姓名搜索
    public List<Contact> searchByName(String name) {
        List<Contact> results = new ArrayList<>();
        String lowerName = name.toLowerCase();
        
        for (Contact contact : contacts.values()) {
            if (contact.getName().toLowerCase().contains(lowerName)) {
                results.add(contact);
            }
        }
        
        return results;
    }
    
    // 按电话搜索
    public Contact searchByPhone(String phone) {
        return contacts.get(phone);
    }
    
    // 获取所有联系人
    public List<Contact> getAllContacts() {
        return new ArrayList<>(contacts.values());
    }
    
    // 按姓名排序获取联系人
    public List<Contact> getSortedContacts() {
        List<Contact> sorted = getAllContacts();
        sorted.sort(Comparator.comparing(Contact::getName));
        return sorted;
    }
    
    // 保存到文件
    private void saveContacts() {
        try (Writer writer = new FileWriter(filename)) {
            gson.toJson(contacts, writer);
        } catch (IOException e) {
            System.out.println("保存文件失败：" + e.getMessage());
        }
    }
    
    // 从文件加载
    private void loadContacts() {
        File file = new File(filename);
        if (!file.exists()) {
            contacts = new HashMap<>();
            return;
        }
        
        try (Reader reader = new FileReader(filename)) {
            java.lang.reflect.Type type = new com.google.gson.reflect.TypeToken<
                Map<String, Contact>>(){}.getType();
            contacts = gson.fromJson(reader, type);
            
            if (contacts == null) {
                contacts = new HashMap<>();
            }
            
            System.out.println("成功加载 " + contacts.size() + " 个联系人");
        } catch (IOException e) {
            System.out.println("加载文件失败：" + e.getMessage());
            contacts = new HashMap<>();
        }
    }
    
    // 显示所有联系人
    public void displayAll() {
        if (contacts.isEmpty()) {
            System.out.println("通讯录为空");
            return;
        }
        
        System.out.println("\n" + "=".repeat(50));
        System.out.println("共有 " + contacts.size() + " 个联系人");
        System.out.println("=".repeat(50));
        
        for (Contact contact : getSortedContacts()) {
            System.out.println(contact);
            System.out.println("-".repeat(50));
        }
    }
}

// 主程序
public class ContactBookApp {
    private static Scanner scanner = new Scanner(System.in);
    private static ContactBook book = new ContactBook("contacts.json");
    
    public static void main(String[] args) {
        while (true) {
            displayMenu();
            String choice = scanner.nextLine().trim();
            
            switch (choice) {
                case "1":
                    addContact();
                    break;
                case "2":
                    deleteContact();
                    break;
                case "3":
                    updateContact();
                    break;
                case "4":
                    searchContact();
                    break;
                case "5":
                    book.displayAll();
                    break;
                case "6":
                    System.out.println("感谢使用，再见！");
                    return;
                default:
                    System.out.println("无效的选择，请重新输入！");
            }
        }
    }
    
    private static void displayMenu() {
        System.out.println("\n" + "=".repeat(50));
        System.out.println("通讯录管理系统");
        System.out.println("=".repeat(50));
        System.out.println("1. 添加联系人");
        System.out.println("2. 删除联系人");
        System.out.println("3. 修改联系人");
        System.out.println("4. 查询联系人");
        System.out.println("5. 显示所有联系人");
        System.out.println("6. 退出");
        System.out.println("=".repeat(50));
        System.out.print("请选择操作 (1-6): ");
    }
    
    private static void addContact() {
        System.out.println("\n--- 添加联系人 ---");
        System.out.print("姓名: ");
        String name = scanner.nextLine().trim();
        System.out.print("电话: ");
        String phone = scanner.nextLine().trim();
        System.out.print("邮箱（可选）: ");
        String email = scanner.nextLine().trim();
        System.out.print("地址（可选）: ");
        String address = scanner.nextLine().trim();
        
        if (!name.isEmpty() && !phone.isEmpty()) {
            Contact contact = new Contact(name, phone, email, address);
            book.addContact(contact);
        } else {
            System.out.println("错误：姓名和电话不能为空！");
        }
    }
    
    private static void deleteContact() {
        System.out.println("\n--- 删除联系人 ---");
        System.out.print("请输入要删除的电话号码: ");
        String phone = scanner.nextLine().trim();
        book.deleteContact(phone);
    }
    
    private static void updateContact() {
        System.out.println("\n--- 修改联系人 ---");
        System.out.print("请输入要修改的电话号码: ");
        String phone = scanner.nextLine().trim();
        
        Contact contact = book.searchByPhone(phone);
        if (contact != null) {
            System.out.println("\n当前信息：");
            System.out.println(contact);
            System.out.println();
            
            System.out.print("新姓名（当前：" + contact.getName() + "，回车跳过）: ");
            String name = scanner.nextLine().trim();
            
            System.out.print("新邮箱（当前：" + contact.getEmail() + "，回车跳过）: ");
            String email = scanner.nextLine().trim();
            
            System.out.print("新地址（当前：" + contact.getAddress() + "，回车跳过）: ");
            String address = scanner.nextLine().trim();
            
            if (!name.isEmpty() || !email.isEmpty() || !address.isEmpty()) {
                book.updateContact(phone, name, email, address);
            } else {
                System.out.println("未进行任何修改");
            }
        }
    }
    
    private static void searchContact() {
        System.out.println("\n--- 查询联系人 ---");
        System.out.println("1. 按姓名查询");
        System.out.println("2. 按电话查询");
        System.out.print("请选择查询方式 (1-2): ");
        String choice = scanner.nextLine().trim();
        
        if (choice.equals("1")) {
            System.out.print("请输入姓名（支持模糊查询）: ");
            String name = scanner.nextLine().trim();
            List<Contact> results = book.searchByName(name);
            
            if (!results.isEmpty()) {
                System.out.println("\n找到 " + results.size() + " 个匹配结果：");
                for (Contact contact : results) {
                    System.out.println("-".repeat(50));
                    System.out.println(contact);
                }
            } else {
                System.out.println("未找到匹配的联系人");
            }
        } else if (choice.equals("2")) {
            System.out.print("请输入电话号码: ");
            String phone = scanner.nextLine().trim();
            Contact contact = book.searchByPhone(phone);
            
            if (contact != null) {
                System.out.println("\n" + "-".repeat(50));
                System.out.println(contact);
            } else {
                System.out.println("未找到该联系人");
            }
        }
    }
}

```



**注意：** Java版本需要添加Gson依赖。如果使用Maven，在pom.xml中添加：

```
xml
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.10.1</version>
</dependency>
```

------

## 3.6 课程总结

### 3.6.1 核心知识点回顾

#### 列表/数组对比

| 特性         | Python List | Java ArrayList | Java LinkedList |
| ------------ | ----------- | -------------- | --------------- |
| **动态大小** | ✓           | ✓              | ✓               |
| **随机访问** | O(1)        | O(1)           | O(n)            |
| **头部插入** | O(n)        | O(n)           | O(1)            |
| **尾部插入** | O(1)        | O(1)           | O(1)            |
| **混合类型** | ✓           | ✗              | ✗               |
| **切片操作** | ✓           | ✗              | ✗               |

#### 字典/Map对比

| 特性           | Python Dict | Java HashMap   | Java TreeMap     |
| -------------- | ----------- | -------------- | ---------------- |
| **键值对存储** | ✓           | ✓              | ✓                |
| **查找速度**   | O(1)        | O(1)           | O(log n)         |
| **保持顺序**   | ✓ (3.7+)    | ✗              | ✓ (排序)         |
| **键类型**     | 可哈希对象  | 需实现hashCode | 需实现Comparable |
| **允许null键** | ✗           | ✓ (一个)       | ✗                |

#### 集合/Set对比

| 特性         | Python Set | Java HashSet | Java TreeSet |
| ------------ | ---------- | ------------ | ------------ |
| **唯一元素** | ✓          | ✓            | ✓            |
| **查找速度** | O(1)       | O(1)         | O(log n)     |
| **保持顺序** | ✗          | ✗            | ✓ (排序)     |
| **集合运算** | ✓ (运算符) | ✗ (方法)     | ✗ (方法)     |

------

### 3.6.2 数据结构选择指南

```python
需要快速查找？
├─ 是 → 需要键值对？
│      ├─ 是 → 使用 Dict/HashMap
│      └─ 否 → 使用 Set/HashSet
└─ 否 → 需要有序？
       ├─ 是 → 需要排序？
       │      ├─ 是 → 使用 TreeMap/TreeSet
       │      └─ 否 → 使用 List/ArrayList
       └─ 否 → 需要唯一？
              ├─ 是 → 使用 Set/HashSet
              └─ 否 → 使用 List/ArrayList
```

------

### 3.6.3 实战经验总结

#### Python最佳实践

```python

# ✓ 推荐：使用列表推导式
squares = [x**2 for x in range(10)]

# ✗ 不推荐：使用循环
squares = []
for x in range(10):
    squares.append(x**2)

# ✓ 推荐：使用字典推导式
word_lengths = {word: len(word) for word in words}

# ✓ 推荐：使用get方法访问字典
value = my_dict.get(key, default_value)

# ✗ 不推荐：直接访问可能不存在的键
# value = my_dict[key]  # 可能KeyError

# ✓ 推荐：使用in检查成员
if item in my_list:
    pass

# ✓ 推荐：使用enumerate遍历
for index, value in enumerate(my_list):
    print(f"{index}: {value}")

# ✓ 推荐：使用zip并行遍历
for name, age in zip(names, ages):
    print(f"{name}: {age}")

# ✓ 推荐：使用defaultdict避免键检查
from collections import defaultdict
counts = defaultdict(int)
for item in items:
    counts[item] += 1

# ✓ 推荐：使用Counter统计
from collections import Counter
counts = Counter(items)
```

#### Java最佳实践

```java

// ✓ 推荐：使用泛型
List<String> names = new ArrayList<>();

// ✗ 不推荐：不使用泛型
List names = new ArrayList();  // 原始类型

// ✓ 推荐：使用接口类型声明
List<String> list = new ArrayList<>();
Map<String, Integer> map = new HashMap<>();

// ✗ 不推荐：使用具体类型
ArrayList<String> list = new ArrayList<>();

// ✓ 推荐：使用Stream API
List<Integer> evens = numbers.stream()
    .filter(n -> n % 2 == 0)
    .collect(Collectors.toList());

// ✓ 推荐：使用forEach遍历
list.forEach(item -> System.out.println(item));

// ✓ 推荐：使用getOrDefault
int value = map.getOrDefault(key, 0);

// ✓ 推荐：使用computeIfAbsent
map.computeIfAbsent(key, k -> new ArrayList<>()).add(value);

// ✓ 推荐：使用diamond运算符（Java 7+）
Map<String, List<Integer>> map = new HashMap<>();

// ✓ 推荐：使用try-with-resources
try (Scanner scanner = new Scanner(file)) {
    // 使用scanner
}

// ✓ 推荐：使用StringBuilder拼接字符串
StringBuilder sb = new StringBuilder();
for (String s : strings) {
    sb.append(s);
}
String result = sb.toString();
```

------

### 3.6.4 常见陷阱

#### Python陷阱

```python

# ❌ 陷阱1：可变默认参数
def add_item(item, lst=[]):  # 危险！
    lst.append(item)
    return lst

# ✓ 正确做法
def add_item(item, lst=None):
    if lst is None:
        lst = []
    lst.append(item)
    return lst

# ❌ 陷阱2：浅拷贝问题
original = [[1, 2], [3, 4]]
copy = original.copy()  # 浅拷贝
copy[0][0] = 999
print(original)  # [[999, 2], [3, 4]]  # 原始数据被修改！

# ✓ 正确做法：深拷贝
import copy
deep_copy = copy.deepcopy(original)

# ❌ 陷阱3：循环中修改列表
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num % 2 == 0:
        numbers.remove(num)  # 危险！

# ✓ 正确做法：使用列表推导式
numbers = [num for num in numbers if num % 2 != 0]

# ❌ 陷阱4：字典遍历时修改
for key in my_dict:
    if condition:
        del my_dict[key]  # RuntimeError!

# ✓ 正确做法：先收集要删除的键
keys_to_delete = [k for k, v in my_dict.items() if condition]
for key in keys_to_delete:
    del my_dict[key]
```

#### Java陷阱

```java

// ❌ 陷阱1：使用==比较对象
String s1 = new String("hello");
String s2 = new String("hello");
if (s1 == s2) {  // false！比较的是引用

// ✓ 正确做法：使用equals
if (s1.equals(s2)) {  // true

// ❌ 陷阱2：ConcurrentModificationException
List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
for (Integer num : list) {
    if (num % 2 == 0) {
        list.remove(num);  // 抛出异常！
    }
}

// ✓ 正确做法：使用Iterator
Iterator<Integer> it = list.iterator();
while (it.hasNext()) {
    if (it.next() % 2 == 0) {
        it.remove();
    }
}

// 或使用removeIf（Java 8+）
list.removeIf(num -> num % 2 == 0);

// ❌ 陷阱3：null值问题
Map<String, Integer> map = new HashMap<>();
int value = map.get("key");  // NullPointerException!

// ✓ 正确做法
Integer value = map.get("key");
if (value != null) {
    // 使用value
}

// 或使用getOrDefault
int value = map.getOrDefault("key", 0);

// ❌ 陷阱4：数组越界
int[] arr = new int[5];
arr[5] = 10;  // ArrayIndexOutOfBoundsException!

// ✓ 正确做法：检查边界
if (index >= 0 && index < arr.length) {
    arr[index] = value;
}
```

------

### 3.6.5 性能优化建议

#### Python性能优化

```python

# 1. 使用生成器表达式代替列表推导式（大数据）
# ✓ 内存友好
sum_of_squares = sum(x**2 for x in range(1000000))

# ✗ 内存占用大
sum_of_squares = sum([x**2 for x in range(1000000)])

# 2. 使用set进行成员检查
# ✓ O(1)
if item in my_set:
    pass

# ✗ O(n)
if item in my_list:
    pass

# 3. 使用join连接字符串
# ✓ 高效
result = ''.join(string_list)

# ✗ 低效
result = ''
for s in string_list:
    result += s

# 4. 使用局部变量
# ✓ 更快
def process():
    local_len = len  # 缓存内置函数
    for item in items:
        if local_len(item) > 10:
            pass

# 5. 使用适当的数据结构
# 需要频繁查找 → 使用dict或set
# 需要保持顺序 → 使用list
# 需要唯一且无序 → 使用set
```

#### Java性能优化

```java
// 1. 指定初始容量
// ✓ 避免频繁扩容
List<String> list = new ArrayList<>(1000);
Map<String, Integer> map = new HashMap<>(1000);

// 2. 使用StringBuilder
// ✓ 高效
StringBuilder sb = new StringBuilder();
for (String s : strings) {
    sb.append(s);
}
String result = sb.toString();

// ✗ 低效
String result = "";
for (String s : strings) {
    result += s;  // 每次创建新对象
}

// 3. 使用原始类型数组（大量数据）
// ✓ 内存效率高
int[] numbers = new int[1000000];

// ✗ 内存占用大
List<Integer> numbers = new ArrayList<>();

// 4. 使用EnumSet和EnumMap
// ✓ 高效
Set<DayOfWeek> weekend = EnumSet.of(DayOfWeek.SATURDAY, DayOfWeek.SUNDAY);

// 5. 避免不必要的装箱拆箱
// ✓ 使用原始类型Stream
int sum = IntStream.range(0, 1000).sum();

// ✗ 装箱开销
int sum = Stream.iterate(0, i -> i + 1)
    .limit(1000)
    .mapToInt(Integer::intValue)
    .sum();
```

------

## 3.7 课后作业

### 必做题

**1. 学生成绩管理系统**

- 添加学生（姓名、学号、成绩）
- 计算平均分
- 找出最高分和最低分
- 按成绩排序

**2. 单词统计程序**

- 读取一段文本
- 统计每个单词出现的次数
- 输出出现次数最多的前10个单词

**3. 去重并排序**

- 输入：包含重复元素的列表
- 输出：去重后按升序排列的列表
- 要求：分别用List、Set实现

### 选做题

**4. 图书管理系统**

- 添加图书（书名、作者、ISBN、库存）
- 借书/还书功能
- 按书名或作者搜索
- 显示库存不足的图书

**5. 购物车系统**

- 添加商品到购物车
- 修改商品数量
- 删除商品
- 计算总价（支持优惠券）
- 数据持久化

**6. 社交网络好友推荐**

- 存储用户及其好友关系
- 推荐共同好友
- 找出好友的好友（二度好友）
- 计算用户之间的距离

------

### 3.8 下节预告

**第四课：面向对象编程（OOP）**

- 类和对象的概念
- 封装、继承、多态
- Python和Java的OOP对比
- 设计模式入门
- 实战：电商系统设计

------

**恭喜你完成第三课！🎉**

数据结构是编程的基石，掌握了它们，你就能更高效地组织和处理数据。记住：

- **选择合适的数据结构是性能优化的第一步**
- **理解底层原理比记住API更重要**
- **通过实践项目巩固理论知识**

准备好进入面向对象的世界了吗？让我们继续前进！💪