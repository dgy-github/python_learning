# 第五课：算法基础入门

欢迎来到第六课！今天我们将学习**算法的基本概念和常用算法**。

------

## 📚 课程目录

1. **什么是算法**
2. **算法复杂度分析**
3. **排序算法**
4. **查找算法**
5. **递归算法**
6. **动态规划入门**
7. **实战练习**

------

## 1️⃣ 什么是算法

### 📖 定义

**算法（Algorithm）**：解决问题的一系列明确步骤。

### 🎯 算法的特性

```
1. 有穷性：算法必须在有限步骤内结束
2. 确定性：每一步都有明确的定义
3. 输入：有零个或多个输入
4. 输出：至少有一个输出
5. 可行性：每一步都可以通过基本操作实现
```

### 💡 示例：求两个数的最大值

```python
# 算法步骤
def find_max(a, b):
    """
    输入：两个数 a 和 b
    输出：较大的数
    步骤：
    1. 比较 a 和 b
    2. 如果 a > b，返回 a
    3. 否则返回 b
    """
    if a > b:
        return a
    else:
        return b

# 测试
print(find_max(10, 20))  # 输出: 20
print(find_max(100, 50)) # 输出: 100
```

------

## 2️⃣ 算法复杂度分析

### 📊 时间复杂度（Time Complexity）

表示算法执行时间随输入规模增长的趋势。

#### 常见时间复杂度（从快到慢）

```scss
O(1)         常数时间    - 最快
O(log n)     对数时间    - 很快（如二分查找）
O(n)         线性时间    - 快
O(n log n)   线性对数    - 较快（如快速排序）
O(n²)        平方时间    - 慢
O(n³)        立方时间    - 很慢
O(2ⁿ)        指数时间    - 极慢
O(n!)        阶乘时间    - 最慢
```

#### 示例代码

```python
# O(1) - 常数时间
def get_first_element(arr):
    return arr[0]  # 无论数组多大，都只执行一次

# O(n) - 线性时间
def sum_array(arr):
    total = 0
    for num in arr:  # 循环 n 次
        total += num
    return total

# O(n²) - 平方时间
def print_pairs(arr):
    for i in arr:      # 外层循环 n 次
        for j in arr:  # 内层循环 n 次
            print(i, j)  # 总共 n × n 次

# O(log n) - 对数时间（二分查找）
def binary_search(arr, target):
    left, right = 0, len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

### 💾 空间复杂度（Space Complexity）

表示算法执行过程中占用的内存空间。

```
python复制# O(1) 空间 - 只用了几个变量
def sum_array(arr):
    total = 0
    for num in arr:
        total += num
    return total

# O(n) 空间 - 创建了新数组
def double_array(arr):
    result = []
    for num in arr:
        result.append(num * 2)
    return result
```

------

## 3️⃣ 排序算法

### 🔹 冒泡排序（Bubble Sort）

**原理**：重复遍历数组，比较相邻元素，如果顺序错误就交换。

```python
def bubble_sort(arr):
    """
    冒泡排序
    时间复杂度：O(n²)
    空间复杂度：O(1)
    """
    n = len(arr)
    
    # 外层循环：需要 n-1 轮
    for i in range(n - 1):
        # 优化：如果某轮没有交换，说明已排序
        swapped = False
        
        # 内层循环：每轮比较相邻元素
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                # 交换
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        
        # 如果没有交换，提前结束
        if not swapped:
            break
    
    return arr

# 测试
arr = [64, 34, 25, 12, 22, 11, 90]
print("原数组:", arr)
print("排序后:", bubble_sort(arr))
# 输出: [11, 12, 22, 25, 34, 64, 90]
```

**动画演示**：

```ini
第1轮: [64, 34, 25, 12, 22, 11, 90]
      [34, 64, 25, 12, 22, 11, 90]
      [34, 25, 64, 12, 22, 11, 90]
      [34, 25, 12, 64, 22, 11, 90]
      [34, 25, 12, 22, 64, 11, 90]
      [34, 25, 12, 22, 11, 64, 90]
      最大值 90 已就位 ✓

第2轮: [34, 25, 12, 22, 11, 64, 90]
      ...
      次大值 64 已就位 ✓
```

------

### 🔹 选择排序（Selection Sort）

**原理**：每次从未排序部分选择最小元素，放到已排序部分末尾。

```python
def selection_sort(arr):
    """
    选择排序
    时间复杂度：O(n²)
    空间复杂度：O(1)
    """
    n = len(arr)
    
    # 外层循环：需要选择 n-1 次
    for i in range(n - 1):
        # 假设当前位置是最小值
        min_index = i
        
        # 在未排序部分找最小值
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        
        # 交换到正确位置
        arr[i], arr[min_index] = arr[min_index], arr[i]
    
    return arr

# 测试
arr = [64, 25, 12, 22, 11]
print("排序后:", selection_sort(arr))
# 输出: [11, 12, 22, 25, 64]
```

------

### 🔹 插入排序（Insertion Sort）

**原理**：将元素插入到已排序部分的正确位置。

```
python复制def insertion_sort(arr):
    """
    插入排序
    时间复杂度：O(n²)
    空间复杂度：O(1)
    适用场景：小规模数据或基本有序的数据
    """
    n = len(arr)
    
    # 从第二个元素开始
    for i in range(1, n):
        key = arr[i]  # 当前要插入的元素
        j = i - 1
        
        # 将大于 key 的元素后移
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        
        # 插入到正确位置
        arr[j + 1] = key
    
    return arr

# 测试
arr = [12, 11, 13, 5, 6]
print("排序后:", insertion_sort(arr))
# 输出: [5, 6, 11, 12, 13]
```

------

### 🔹 快速排序（Quick Sort）⭐

**原理**：选择基准值，将数组分为小于和大于基准的两部分，递归排序。

```python
def quick_sort(arr):
    """
    快速排序
    时间复杂度：平均 O(n log n)，最坏 O(n²)
    空间复杂度：O(log n)
    """
    # 基准情况
    if len(arr) <= 1:
        return arr
    
    # 选择基准值（这里选中间元素）
    pivot = arr[len(arr) // 2]
    
    # 分区
    left = [x for x in arr if x < pivot]    # 小于基准
    middle = [x for x in arr if x == pivot] # 等于基准
    right = [x for x in arr if x > pivot]   # 大于基准
    
    # 递归排序并合并
    return quick_sort(left) + middle + quick_sort(right)

# 测试
arr = [64, 34, 25, 12, 22, 11, 90]
print("排序后:", quick_sort(arr))
# 输出: [11, 12, 22, 25, 34, 64, 90]
```

------

### 🔹 归并排序（Merge Sort）⭐

**原理**：分而治之，将数组分成两半，分别排序后合并。

```python
def merge_sort(arr):
    """
    归并排序
    时间复杂度：O(n log n)
    空间复杂度：O(n)
    """
    # 基准情况
    if len(arr) <= 1:
        return arr
    
    # 分割
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    
    # 合并
    return merge(left, right)

def merge(left, right):
    """合并两个有序数组"""
    result = []
    i = j = 0
    
    # 比较并合并
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    
    # 添加剩余元素
    result.extend(left[i:])
    result.extend(right[j:])
    
    return result

# 测试
arr = [64, 34, 25, 12, 22, 11, 90]
print("排序后:", merge_sort(arr))
# 输出: [11, 12, 22, 25, 34, 64, 90]
```

------

## 4️⃣ 查找算法

### 🔹 线性查找（Linear Search）

```python
def linear_search(arr, target):
    """
    线性查找
    时间复杂度：O(n)
    """
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # 返回索引
    return -1  # 未找到

# 测试
arr = [64, 34, 25, 12, 22]
print(linear_search(arr, 25))  # 输出: 2
print(linear_search(arr, 100)) # 输出: -1
```

------

### 🔹 二分查找（Binary Search）⭐

**前提**：数组必须是有序的。

```python
def binary_search(arr, target):
    """
    二分查找（迭代版本）
    时间复杂度：O(log n)
    """
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            return mid  # 找到了
        elif arr[mid] < target:
            left = mid + 1  # 在右半部分
        else:
            right = mid - 1  # 在左半部分
    
    return -1  # 未找到

# 递归版本
def binary_search_recursive(arr, target, left, right):
    """二分查找（递归版本）"""
    if left > right:
        return -1
    
    mid = (left + right) // 2
    
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return binary_search_recursive(arr, target, mid + 1, right)
    else:
        return binary_search_recursive(arr, target, left, mid - 1)

# 测试
arr = [11, 12, 22, 25, 34, 64, 90]
print(binary_search(arr, 25))  # 输出: 3
print(binary_search(arr, 100)) # 输出: -1
```

**动画演示**：

```ini
查找 25 在 [11, 12, 22, 25, 34, 64, 90] 中

第1步: left=0, right=6, mid=3
      arr[3]=25 ✓ 找到了！
```

------

## 5️⃣ 递归算法

### 📖 什么是递归

**递归**：函数调用自己的过程。

### 🎯 递归的三要素

```markdown
1. 递归终止条件（基准情况）
2. 递归公式（如何分解问题）
3. 递归调用（调用自己）
```

### 💡 经典示例

#### 示例 1：阶乘

```python
def factorial(n):
    """
    计算 n 的阶乘
    n! = n × (n-1) × (n-2) × ... × 1
    """
    # 基准情况
    if n == 0 or n == 1:
        return 1
    
    # 递归调用
    return n * factorial(n - 1)

# 测试
print(factorial(5))  # 5! = 5×4×3×2×1 = 120
print(factorial(0))  # 0! = 1
```

**执行过程**：

```
scss复制factorial(5)
= 5 × factorial(4)
= 5 × 4 × factorial(3)
= 5 × 4 × 3 × factorial(2)
= 5 × 4 × 3 × 2 × factorial(1)
= 5 × 4 × 3 × 2 × 1
= 120
```

------

#### 示例 2：斐波那契数列

```python
def fibonacci(n):
    """
    斐波那契数列
    F(0) = 0, F(1) = 1
    F(n) = F(n-1) + F(n-2)
    """
    # 基准情况
    if n == 0:
        return 0
    if n == 1:
        return 1
    
    # 递归调用
    return fibonacci(n - 1) + fibonacci(n - 2)

# 测试
for i in range(10):
    print(f"F({i}) = {fibonacci(i)}")
# 输出: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

------

#### 示例 3：汉诺塔问题

```python
def hanoi(n, source, target, auxiliary):
    """
    汉诺塔问题
    n: 盘子数量
    source: 起始柱
    target: 目标柱
    auxiliary: 辅助柱
    """
    if n == 1:
        print(f"移动盘子 1 从 {source} 到 {target}")
        return
    
    # 1. 将 n-1 个盘子从 source 移到 auxiliary
    hanoi(n - 1, source, auxiliary, target)
    
    # 2. 将最大的盘子从 source 移到 target
    print(f"移动盘子 {n} 从 {source} 到 {target}")
    
    # 3. 将 n-1 个盘子从 auxiliary 移到 target
    hanoi(n - 1, auxiliary, target, source)

# 测试
hanoi(3, 'A', 'C', 'B')
```

------

## 6️⃣ 动态规划入门

### 📖 什么是动态规划

**动态规划（Dynamic Programming, DP）**：将复杂问题分解为子问题，保存子问题的解，避免重复计算。

### 🎯 适用场景

```
markdown复制1. 最优子结构：问题的最优解包含子问题的最优解
2. 重叠子问题：子问题会被多次计算
```

### 💡 示例：斐波那契数列优化

```python
# 方法1：递归（慢，有重复计算）
def fib_recursive(n):
    if n <= 1:
        return n
    return fib_recursive(n - 1) + fib_recursive(n - 2)

# 方法2：动态规划（快，避免重复计算）
def fib_dp(n):
    """
    使用动态规划计算斐波那契数列
    时间复杂度：O(n)
    空间复杂度：O(n)
    """
    if n <= 1:
        return n
    
    # 创建 DP 数组
    dp = [0] * (n + 1)
    dp[0] = 0
    dp[1] = 1
    
    # 自底向上计算
    for i in range(2, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    return dp[n]

# 方法3：空间优化版本
def fib_optimized(n):
    """
    空间优化版本
    时间复杂度：O(n)
    空间复杂度：O(1)
    """
    if n <= 1:
        return n
    
    prev2, prev1 = 0, 1
    
    for i in range(2, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1

# 性能对比
import time

n = 35

start = time.time()
result1 = fib_recursive(n)
print(f"递归: {result1}, 耗时: {time.time() - start:.4f}秒")

start = time.time()
result2 = fib_dp(n)
print(f"动态规划: {result2}, 耗时: {time.time() - start:.4f}秒")

start = time.time()
result3 = fib_optimized(n)
print(f"优化版本: {result3}, 耗时: {time.time() - start:.4f}秒")
```

------

## 7️⃣ 实战练习

### 📝 练习 1：找出数组中的最大值和最小值

```python
def find_max_min(arr):
    """
    找出数组中的最大值和最小值
    要求：只遍历一次数组
    """
    if not arr:
        return None, None
    
    max_val = min_val = arr[0]
    
    for num in arr[1:]:
        if num > max_val:
            max_val = num
        if num < min_val:
            min_val = num
    
    return max_val, min_val

# 测试
arr = [3, 7, 2, 9, 1, 5]
max_val, min_val = find_max_min(arr)
print(f"最大值: {max_val}, 最小值: {min_val}")
# 输出: 最大值: 9, 最小值: 1
```

------

### 📝 练习 2：反转字符串

```python
# 方法1：使用切片
def reverse_string_v1(s):
    return s[::-1]

# 方法2：使用循环
def reverse_string_v2(s):
    result = ""
    for char in s:
        result = char + result
    return result

# 方法3：使用递归
def reverse_string_v3(s):
    if len(s) <= 1:
        return s
    return reverse_string_v3(s[1:]) + s[0]

# 测试
s = "Hello"
print(reverse_string_v1(s))  # olleH
print(reverse_string_v2(s))  # olleH
print(reverse_string_v3(s))  # olleH
```

------

### 📝 练习 3：判断回文字符串

```python
def is_palindrome(s):
    """
    判断字符串是否是回文
    回文：正读和反读都一样，如 "level", "noon"
    """
    # 方法1：使用切片
    return s == s[::-1]

# 方法2：双指针
def is_palindrome_v2(s):
    left, right = 0, len(s) - 1
    
    while left < right:
        if s[left] != s[right]:
            return False
        left += 1
        right -= 1
    
    return True

# 测试
print(is_palindrome("level"))   # True
print(is_palindrome("hello"))   # False
print(is_palindrome("noon"))    # True
```

------

### 📝 练习 4：两数之和（LeetCode 第1题）

```python
def two_sum(nums, target):
    """
    给定一个整数数组和目标值，找出数组中和为目标值的两个数的索引
    
    示例:
    输入: nums = [2, 7, 11, 15], target = 9
    输出: [0, 1]  (因为 nums[0] + nums[1] = 2 + 7 = 9)
    """
    # 使用哈希表
    seen = {}
    
    for i, num in enumerate(nums):
        complement = target - num
        
        if complement in seen:
            return [seen[complement], i]
        
        seen[num] = i
    
    return []

# 测试
nums = [2, 7, 11, 15]
target = 9
print(two_sum(nums, target))  # [0, 1]
```

------

### 📝 练习 5：爬楼梯（LeetCode 第70题）

```python
def climb_stairs(n):
    """
    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
    
    示例:
    输入: 3
    输出: 3
    解释: 有三种方法可以爬到楼顶。
    1. 1 阶 + 1 阶 + 1 阶
    2. 1 阶 + 2 阶
    3. 2 阶 + 1 阶
    """
    if n <= 2:
        return n
    
    # 动态规划
    prev2, prev1 = 1, 2
    
    for i in range(3, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1

# 测试
for i in range(1, 6):
    print(f"爬 {i} 阶楼梯有 {climb_stairs(i)} 种方法")
```

------

## 📚 课后作业

### 作业 1：实现冒泡排序的优化版本

要求：添加标志位，如果某轮没有交换，提前结束。

### 作业 2：实现二分查找的递归版本

要求：使用递归实现二分查找。

### 作业 3：计算数组中第 K 大的元素

提示：可以使用排序或堆。

### 作业 4：合并两个有序数组

给定两个有序数组，合并成一个有序数组。

### 作业 5：最大子数组和（LeetCode 第53题）

给定一个整数数组，找到一个具有最大和的连续子数组。

------

## 🎯 学习建议

1. **理解原理**：不要死记硬背代码，理解算法的思想
2. **多练习**：在 LeetCode、牛客网等平台刷题
3. **画图分析**：复杂算法可以画图帮助理解
4. **对比优化**：学会分析时间和空间复杂度
5. **循序渐进**：从简单题目开始，逐步提高难度

------

## 🌟 下节预告

**第七课：面向对象编程（OOP）**

- 类和对象
- 封装、继承、多态
- 设计模式入门

------

恭喜你完成第六课！🎉

算法是编程的核心，掌握常用算法将让你的代码更高效。继续加油！💪